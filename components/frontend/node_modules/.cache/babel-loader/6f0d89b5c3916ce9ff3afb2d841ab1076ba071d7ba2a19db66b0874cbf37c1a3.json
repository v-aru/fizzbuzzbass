{"ast":null,"code":"// -*- js-indent-level: 2 -*-\n\n// Constructors given patterns\n\n'use strict';\n\nvar ints = require('buffer-more-ints');\n\n// Interpret the pattern, writing values into a buffer\nfunction write(buf, offset, pattern, bindings) {\n  for (var i = 0, len = pattern.length; i < len; i++) {\n    var segment = pattern[i];\n    switch (segment.type) {\n      case 'string':\n        offset += buf.write(segment.value, offset, 'utf8');\n        break;\n      case 'binary':\n        offset += writeBinary(segment, buf, offset, bindings);\n        break;\n      case 'integer':\n        offset += writeInteger(segment, buf, offset, bindings);\n        break;\n      case 'float':\n        offset += writeFloat(segment, buf, offset, bindings);\n        break;\n    }\n  }\n  return offset;\n}\nfunction build(pattern, bindings) {\n  var bufsize = size_of(pattern, bindings);\n  var buf = new Buffer(bufsize);\n  write(buf, 0, pattern, bindings);\n  return buf;\n}\n\n// In bytes\nfunction size_of_segment(segment, bindings) {\n  // size refers to a variable\n  if (typeof segment.size === 'string') {\n    return bindings[segment.size] * segment.unit / 8;\n  }\n  if (segment.type === 'string') {\n    return Buffer.byteLength(segment.value, 'utf8');\n  }\n  if (segment.type === 'binary' && segment.size === true) {\n    var val = bindings[segment.name];\n    return val.length;\n  }\n  return segment.size * segment.unit / 8;\n}\n\n// size of the to-be-constructed binary, in bytes\nfunction size_of(segments, bindings) {\n  var size = 0;\n  for (var i = 0, len = segments.length; i < len; i++) {\n    size += size_of_segment(segments[i], bindings);\n  }\n  return size;\n}\nfunction writeBinary(segment, buf, offset, bindings) {\n  var bin = bindings[segment.name];\n  var size = size_of_segment(segment, bindings);\n  bin.copy(buf, offset, 0, size);\n  return size;\n}\n\n// TODO in ff might use the noAssert argument to Buffer.write*() but\n// need to check that it does the right thing wrt little-endian\n\nfunction writeInteger(segment, buf, offset, bindings) {\n  var value = segment.name ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_int(buf, value, offset, size, segment.bigendian);\n}\nfunction write_int(buf, value, offset, size, bigendian) {\n  switch (size) {\n    case 1:\n      buf.writeUInt8(value, offset);\n      break;\n    case 2:\n      bigendian ? buf.writeUInt16BE(value, offset) : buf.writeUInt16LE(value, offset);\n      break;\n    case 4:\n      bigendian ? buf.writeUInt32BE(value, offset) : buf.writeUInt32LE(value, offset);\n      break;\n    case 8:\n      bigendian ? ints.writeUInt64BE(buf, value, offset) : ints.writeUInt64LE(buf, value, offset);\n      break;\n    default:\n      throw new Error(\"integer size * unit must be 8, 16, 32 or 64\");\n  }\n  return size;\n}\nfunction writeFloat(segment, buf, offset, bindings) {\n  var value = segment.name ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_float(buf, value, offset, size, segment.bigendian);\n}\nfunction write_float(buf, value, offset, size, bigendian) {\n  if (size === 4) {\n    bigendian ? buf.writeFloatBE(value, offset) : buf.writeFloatLE(value, offset);\n  } else if (size === 8) {\n    bigendian ? buf.writeDoubleBE(value, offset) : buf.writeDoubleLE(value, offset);\n  } else {\n    throw new Error(\"float size * unit must be 32 or 64\");\n  }\n  return size;\n}\nvar parse = require('./parse').parse;\nmodule.exports.write = write;\nmodule.exports.build = build;\nmodule.exports.write_int = write_int;\nmodule.exports.write_float = write_float;\nmodule.exports.builder = function (pstr) {\n  pstr = arguments.length > 1 ? [].join.call(arguments, ',') : pstr;\n  var pattern = parse(pstr);\n  return function (vars) {\n    return build(pattern, vars);\n  };\n};","map":{"version":3,"names":["ints","require","write","buf","offset","pattern","bindings","i","len","length","segment","type","value","writeBinary","writeInteger","writeFloat","build","bufsize","size_of","Buffer","size_of_segment","size","unit","byteLength","val","name","segments","bin","copy","write_int","bigendian","writeUInt8","writeUInt16BE","writeUInt16LE","writeUInt32BE","writeUInt32LE","writeUInt64BE","writeUInt64LE","Error","write_float","writeFloatBE","writeFloatLE","writeDoubleBE","writeDoubleLE","parse","module","exports","builder","pstr","arguments","join","call","vars"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/bitsyntax/lib/constructor.js"],"sourcesContent":["// -*- js-indent-level: 2 -*-\n\n// Constructors given patterns\n\n'use strict';\n\nvar ints = require('buffer-more-ints');\n\n// Interpret the pattern, writing values into a buffer\nfunction write(buf, offset, pattern, bindings) {\n  for (var i=0, len = pattern.length; i < len; i++) {\n    var segment = pattern[i];\n    \n    switch (segment.type) {\n    case 'string':\n      offset += buf.write(segment.value, offset, 'utf8');\n      break;\n    case 'binary':\n      offset += writeBinary(segment, buf, offset, bindings);\n      break;\n    case 'integer':\n      offset += writeInteger(segment, buf, offset, bindings);\n      break;\n    case 'float':\n      offset += writeFloat(segment, buf, offset, bindings);\n      break;\n    }\n  }\n  return offset;\n}\n\nfunction build(pattern, bindings) {\n  var bufsize = size_of(pattern, bindings);\n  var buf = new Buffer(bufsize);\n  write(buf, 0, pattern, bindings);\n  return buf;\n}\n\n// In bytes\nfunction size_of_segment(segment, bindings) {\n  // size refers to a variable\n  if (typeof segment.size === 'string') {\n    return (bindings[segment.size] * segment.unit) / 8;\n  }\n  if (segment.type === 'string') {\n    return Buffer.byteLength(segment.value, 'utf8');\n  }\n  if (segment.type === 'binary' && segment.size === true) {\n    var val = bindings[segment.name];\n    return val.length;\n  }\n  return (segment.size * segment.unit) / 8;\n}\n\n// size of the to-be-constructed binary, in bytes\nfunction size_of(segments, bindings) {\n  var size = 0;\n  for (var i=0, len = segments.length; i < len; i++) {\n    size += size_of_segment(segments[i], bindings);\n  }\n  return size;\n}\n\nfunction writeBinary(segment, buf, offset, bindings) {\n  var bin = bindings[segment.name];\n  var size = size_of_segment(segment, bindings);\n  bin.copy(buf, offset, 0, size);\n  return size;\n}\n\n// TODO in ff might use the noAssert argument to Buffer.write*() but\n// need to check that it does the right thing wrt little-endian\n\nfunction writeInteger(segment, buf, offset, bindings) {\n  var value = (segment.name) ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_int(buf, value, offset, size, segment.bigendian);\n}\n\nfunction write_int(buf, value, offset, size, bigendian) {\n  switch (size) {\n  case 1:\n    buf.writeUInt8(value, offset);\n    break;\n  case 2:\n    (bigendian) ?\n      buf.writeUInt16BE(value, offset) :\n      buf.writeUInt16LE(value, offset);\n    break;\n  case 4:\n    (bigendian) ?\n      buf.writeUInt32BE(value, offset) :\n      buf.writeUInt32LE(value, offset);\n    break;\n  case 8:\n    (bigendian) ?\n      ints.writeUInt64BE(buf, value, offset) :\n      ints.writeUInt64LE(buf, value, offset);\n    break;\n  default:\n    throw new Error(\"integer size * unit must be 8, 16, 32 or 64\");\n  }\n  return size;\n}\n\nfunction writeFloat(segment, buf, offset, bindings) {\n  var value = (segment.name) ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_float(buf, value, offset, size, segment.bigendian);\n}\n\nfunction write_float(buf, value, offset, size, bigendian) {\n  if (size === 4) {\n    (bigendian) ?\n      buf.writeFloatBE(value, offset) :\n      buf.writeFloatLE(value, offset);\n  }\n  else if (size === 8) {\n    (bigendian) ?\n      buf.writeDoubleBE(value, offset) :\n      buf.writeDoubleLE(value, offset);\n  }\n  else {\n    throw new Error(\"float size * unit must be 32 or 64\");\n  }\n  return size;\n}\n\nvar parse = require('./parse').parse;\n\nmodule.exports.write = write;\nmodule.exports.build = build;\nmodule.exports.write_int = write_int;\nmodule.exports.write_float = write_float;\n\nmodule.exports.builder = function(pstr) {\n  pstr = (arguments.length > 1) ? [].join.call(arguments, ',') : pstr;\n  var pattern = parse(pstr);\n  return function(vars) {\n    return build(pattern, vars);\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}