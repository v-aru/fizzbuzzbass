{"ast":null,"code":"//\n//\n//\n\n// Heartbeats. In AMQP both clients and servers may expect a heartbeat\n// frame if there is no activity on the connection for a negotiated\n// period of time. If there's no activity for two such intervals, the\n// server or client is allowed to close the connection on the\n// presumption that the other party is dead.\n//\n// The client has two jobs here: the first is to send a heartbeat\n// frame if it's not sent any frames for a while, so that the server\n// doesn't think it's dead; the second is to check periodically that\n// it's seen activity from the server, and to advise if there doesn't\n// appear to have been any for over two intervals.\n//\n// Node.JS timers are a bit unreliable, in that they endeavour only to\n// fire at some indeterminate point *after* the given time (rather\n// gives the lie to 'realtime', dunnit). Because the scheduler is just\n// an event loop, it's quite easy to delay timers indefinitely by\n// reacting to some I/O with a lot of computation.\n//\n// To mitigate this I need a bit of creative interpretation:\n//\n//  - I'll schedule a server activity check for every `interval`, and\n//    check just how much time has passed. It will overshoot by at\n//    least a small margin; modulo missing timer deadlines, it'll\n//    notice between two and three intervals after activity actually\n//    stops (otherwise, at some point after two intervals).\n//\n//  - Every `interval / 2` I'll check that we've sent something since\n//    the last check, and if not, send a heartbeat frame. If we're\n//    really too busy to even run the check for two whole heartbeat\n//    intervals, there must be a lot of I (but not O, at least not on\n//    the connection), or computation, in which case perhaps it's best\n//    the server cuts us off anyway. Why `interval / 2`? Because the\n//    edge case is that the client sent a frame just after a\n//    heartbeat, which would mean I only send one after almost two\n//    intervals. (NB a heartbeat counts as a send, so it'll be checked\n//    at least twice before sending another)\n//\n// This design is based largely on RabbitMQ's heartbeating:\n// https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_heartbeat.erl\n\n// %% Yes, I could apply the same 'actually passage of time' thing to\n// %% send as well as to recv.\n\n'use strict';\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\n// Exported so that we can mess with it in tests\nmodule.exports.UNITS_TO_MS = 1000;\nfunction Heart(interval, checkSend, checkRecv) {\n  EventEmitter.call(this);\n  this.interval = interval;\n  var intervalMs = interval * module.exports.UNITS_TO_MS;\n  // Function#bind is my new best friend\n  var beat = this.emit.bind(this, 'beat');\n  var timeout = this.emit.bind(this, 'timeout');\n  this.sendTimer = setInterval(this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);\n\n  // A timeout occurs if I see nothing for *two consecutive* intervals\n  var recvMissed = 0;\n  function missedTwo() {\n    if (!checkRecv()) return ++recvMissed < 2;else {\n      recvMissed = 0;\n      return true;\n    }\n  }\n  this.recvTimer = setInterval(this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);\n}\ninherits(Heart, EventEmitter);\nmodule.exports.Heart = Heart;\nHeart.prototype.clear = function () {\n  clearInterval(this.sendTimer);\n  clearInterval(this.recvTimer);\n};\nHeart.prototype.runHeartbeat = function (check, fail) {\n  // Have we seen activity?\n  if (!check()) fail();\n};","map":{"version":3,"names":["inherits","require","EventEmitter","module","exports","UNITS_TO_MS","Heart","interval","checkSend","checkRecv","call","intervalMs","beat","emit","bind","timeout","sendTimer","setInterval","runHeartbeat","recvMissed","missedTwo","recvTimer","prototype","clear","clearInterval","check","fail"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/amqplib/lib/heartbeat.js"],"sourcesContent":["//\n//\n//\n\n// Heartbeats. In AMQP both clients and servers may expect a heartbeat\n// frame if there is no activity on the connection for a negotiated\n// period of time. If there's no activity for two such intervals, the\n// server or client is allowed to close the connection on the\n// presumption that the other party is dead.\n//\n// The client has two jobs here: the first is to send a heartbeat\n// frame if it's not sent any frames for a while, so that the server\n// doesn't think it's dead; the second is to check periodically that\n// it's seen activity from the server, and to advise if there doesn't\n// appear to have been any for over two intervals.\n//\n// Node.JS timers are a bit unreliable, in that they endeavour only to\n// fire at some indeterminate point *after* the given time (rather\n// gives the lie to 'realtime', dunnit). Because the scheduler is just\n// an event loop, it's quite easy to delay timers indefinitely by\n// reacting to some I/O with a lot of computation.\n//\n// To mitigate this I need a bit of creative interpretation:\n//\n//  - I'll schedule a server activity check for every `interval`, and\n//    check just how much time has passed. It will overshoot by at\n//    least a small margin; modulo missing timer deadlines, it'll\n//    notice between two and three intervals after activity actually\n//    stops (otherwise, at some point after two intervals).\n//\n//  - Every `interval / 2` I'll check that we've sent something since\n//    the last check, and if not, send a heartbeat frame. If we're\n//    really too busy to even run the check for two whole heartbeat\n//    intervals, there must be a lot of I (but not O, at least not on\n//    the connection), or computation, in which case perhaps it's best\n//    the server cuts us off anyway. Why `interval / 2`? Because the\n//    edge case is that the client sent a frame just after a\n//    heartbeat, which would mean I only send one after almost two\n//    intervals. (NB a heartbeat counts as a send, so it'll be checked\n//    at least twice before sending another)\n//\n// This design is based largely on RabbitMQ's heartbeating:\n// https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_heartbeat.erl\n\n// %% Yes, I could apply the same 'actually passage of time' thing to\n// %% send as well as to recv.\n\n'use strict';\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\n// Exported so that we can mess with it in tests\nmodule.exports.UNITS_TO_MS = 1000;\n\nfunction Heart(interval, checkSend, checkRecv) {\n  EventEmitter.call(this);\n  this.interval = interval;\n\n  var intervalMs = interval * module.exports.UNITS_TO_MS;\n  // Function#bind is my new best friend\n  var beat = this.emit.bind(this, 'beat');\n  var timeout = this.emit.bind(this, 'timeout');\n\n  this.sendTimer = setInterval(\n    this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);\n\n  // A timeout occurs if I see nothing for *two consecutive* intervals\n  var recvMissed = 0;\n  function missedTwo() {\n    if (!checkRecv()) return (++recvMissed < 2);\n    else { recvMissed = 0; return true; }\n  }\n  this.recvTimer = setInterval(\n    this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);\n}\ninherits(Heart, EventEmitter);\n\nmodule.exports.Heart = Heart;\n\nHeart.prototype.clear = function() {\n  clearInterval(this.sendTimer);\n  clearInterval(this.recvTimer);\n};\n\nHeart.prototype.runHeartbeat = function(check, fail) {\n  // Have we seen activity?\n  if (!check()) fail();\n};\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,QAAQ,GAAGC,OAAO,CAAC,MAAM,CAAC,CAACD,QAAQ;AACvC,IAAIE,YAAY,GAAGD,OAAO,CAAC,QAAQ,CAAC,CAACC,YAAY;;AAEjD;AACAC,MAAM,CAACC,OAAO,CAACC,WAAW,GAAG,IAAI;AAEjC,SAASC,KAAKA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,SAAS,EAAE;EAC7CP,YAAY,CAACQ,IAAI,CAAC,IAAI,CAAC;EACvB,IAAI,CAACH,QAAQ,GAAGA,QAAQ;EAExB,IAAII,UAAU,GAAGJ,QAAQ,GAAGJ,MAAM,CAACC,OAAO,CAACC,WAAW;EACtD;EACA,IAAIO,IAAI,GAAG,IAAI,CAACC,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC;EACvC,IAAIC,OAAO,GAAG,IAAI,CAACF,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC;EAE7C,IAAI,CAACE,SAAS,GAAGC,WAAW,CAC1B,IAAI,CAACC,YAAY,CAACJ,IAAI,CAAC,IAAI,EAAEN,SAAS,EAAEI,IAAI,CAAC,EAAED,UAAU,GAAG,CAAC,CAAC;;EAEhE;EACA,IAAIQ,UAAU,GAAG,CAAC;EAClB,SAASC,SAASA,CAAA,EAAG;IACnB,IAAI,CAACX,SAAS,CAAC,CAAC,EAAE,OAAQ,EAAEU,UAAU,GAAG,CAAC,CAAE,KACvC;MAAEA,UAAU,GAAG,CAAC;MAAE,OAAO,IAAI;IAAE;EACtC;EACA,IAAI,CAACE,SAAS,GAAGJ,WAAW,CAC1B,IAAI,CAACC,YAAY,CAACJ,IAAI,CAAC,IAAI,EAAEM,SAAS,EAAEL,OAAO,CAAC,EAAEJ,UAAU,CAAC;AACjE;AACAX,QAAQ,CAACM,KAAK,EAAEJ,YAAY,CAAC;AAE7BC,MAAM,CAACC,OAAO,CAACE,KAAK,GAAGA,KAAK;AAE5BA,KAAK,CAACgB,SAAS,CAACC,KAAK,GAAG,YAAW;EACjCC,aAAa,CAAC,IAAI,CAACR,SAAS,CAAC;EAC7BQ,aAAa,CAAC,IAAI,CAACH,SAAS,CAAC;AAC/B,CAAC;AAEDf,KAAK,CAACgB,SAAS,CAACJ,YAAY,GAAG,UAASO,KAAK,EAAEC,IAAI,EAAE;EACnD;EACA,IAAI,CAACD,KAAK,CAAC,CAAC,EAAEC,IAAI,CAAC,CAAC;AACtB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}