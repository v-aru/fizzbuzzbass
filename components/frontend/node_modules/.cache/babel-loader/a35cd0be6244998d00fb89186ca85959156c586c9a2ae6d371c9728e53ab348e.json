{"ast":null,"code":"// Compile patterns to recognisers and constructors\n\n'use strict';\n\nrequire('buffer-more-ints');\nvar $ = require('util').format;\nvar parse = require('./parse').parse;\nvar interp = require('./interp'),\n  parse_int = interp.parse_int,\n  parse_float = interp.parse_float;\nvar construct = require('./constructor'),\n  write_int = construct.write_int,\n  write_float = construct.write_float;\nvar lines = [];\nfunction $start() {\n  lines = [];\n}\nfunction $line(/* format , args */\n) {\n  lines.push($.apply(null, arguments));\n}\nfunction $result() {\n  return lines.join('\\n');\n}\nfunction bits_expr(segment) {\n  if (typeof segment.size === 'string') {\n    return $('%s * %d', var_name(segment.size), segment.unit);\n  } else {\n    return (segment.size * segment.unit).toString();\n  }\n}\nfunction get_number(segment) {\n  $line('bits = %s;\\n', bits_expr(segment));\n  var parser = segment.type === 'integer' ? 'parse_int' : 'parse_float';\n  var be = segment.bigendian,\n    sg = segment.signed;\n  $line(\"byteoffset = offset / 8; offset += bits\");\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = %s(bin, byteoffset, bits / 8, %s, %s); }\", parser, be, sg);\n}\nfunction get_binary(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  if (segment.size === true) {\n    $line(\"offset = binsize;\");\n    $line(\"result = bin.slice(byteoffset);\");\n  } else {\n    $line(\"bits = %s;\", bits_expr(segment));\n    $line(\"offset += bits;\");\n    $line(\"if (offset > binsize) { return false; }\");\n    $line(\"else { result = bin.slice(byteoffset,\", \"byteoffset + bits / 8); }\");\n  }\n}\nfunction get_string(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  var strlen = segment.value.length;\n  var strlenbits = strlen * 8;\n  $line(\"offset += %d;\", strlenbits);\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = bin.toString(byteoffset,\", $(\"byteoffset + %d); }\", strlen));\n}\nfunction skip_bits(segment) {\n  if (typeof segment.size === 'string') {\n    // Damn. Have to look up the size.\n    $line(\"var skipbits = %s * %d;\", var_name(segment.size), segment.unit);\n    $line(\"if (offset + skipbits > binsize) { return false; }\");\n    $line(\"else { offset += skipbits; }\");\n  } else if (segment.size === true) {\n    $line(\"if (offset % 8 === 0) { offset = binsize; }\");\n    $line(\"else { return false; }\");\n  } else {\n    var bits = segment.unit * segment.size;\n    $line(\"if (offset + %d > binsize) { return false; }\", bits);\n    $line(\"else { offset += %d; }\", bits);\n  }\n}\nfunction match_seg(segment) {\n  if (segment.name === '_') {\n    skip_bits(segment);\n  } else {\n    var assign_result;\n    switch (segment.type) {\n      case 'integer':\n      case 'float':\n        get_number(segment);\n        break;\n      case 'binary':\n        get_binary(segment);\n        break;\n      case 'string':\n        get_string(segment);\n        break;\n    }\n    $line(\"if (result === false) return false;\");\n    if (segment.name) {\n      // variable is given a value in the environment\n      $line(\"else if (%s !== undefined) {\", var_name(segment.name));\n      // .. and it is not the same as that matched\n      $line(\"if (%s != result) return false;\", var_name(segment.name));\n      $line(\"}\");\n      // variable is free\n      $line('else %s = result;', var_name(segment.name));\n    } else {\n      var repr = JSON.stringify(segment.value);\n      $line(\"else if (result != %s) return false;\", repr);\n    }\n  }\n}\nfunction var_name(name) {\n  return 'var_' + name;\n}\nfunction variables(segments) {\n  var names = {};\n  for (var i = 0; i < segments.length; i++) {\n    var name = segments[i].name;\n    if (name && name !== '_') {\n      names[name] = true;\n    }\n    name = segments[i].size;\n    if (typeof name === 'string') {\n      names[name] = true;\n    }\n  }\n  return Object.keys(names);\n}\nfunction compile_pattern(segments) {\n  $start();\n  $line(\"return function(binary, env) {\");\n  $line(\"'use strict';\");\n  $line(\"var bin = binary, env = env || {};\");\n  $line(\"var offset = 0, binsize = bin.length * 8;\");\n  $line(\"var bits, result, byteoffset;\");\n  var varnames = variables(segments);\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"var %s = env['%s'];\", var_name(name), name);\n  }\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line(\"// \" + JSON.stringify(segment));\n    match_seg(segment);\n  }\n  $line(\"if (offset == binsize) {\");\n  $line(\"return {\");\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"%s: %s,\", name, var_name(name));\n  }\n  $line('};');\n  $line('}'); // if offset == binsize\n  $line(\"else return false;\");\n  $line(\"}\"); // end function\n\n  var fn = new Function('parse_int', 'parse_float', $result());\n  return fn(parse_int, parse_float);\n}\nfunction write_seg(segment) {\n  switch (segment.type) {\n    case 'string':\n      $line(\"offset += buf.write(%s, offset, 'utf8');\", JSON.stringify(segment.value));\n      break;\n    case 'binary':\n      $line(\"val = bindings['%s'];\", segment.name);\n      if (segment.size === true) {\n        $line('size = val.length;');\n      } else if (typeof segment.size === 'string') {\n        $line(\"size = (bindings['%s'] * %d) / 8;\", segment.size, segment.unit);\n      } else {\n        $line(\"size = %d;\", segment.size * segment.unit / 8);\n      }\n      $line('val.copy(buf, offset, 0, size);');\n      $line('offset += size;');\n      break;\n    case 'integer':\n    case 'float':\n      write_number(segment);\n      break;\n  }\n}\nfunction write_number(segment) {\n  if (segment.name) {\n    $line(\"val = bindings['%s'];\", segment.name);\n  } else {\n    $line(\"val = %d\", segment.value);\n  }\n  var writer = segment.type === 'integer' ? 'write_int' : 'write_float';\n  if (typeof segment.size === 'string') {\n    $line(\"size = (bindings['%s'] * %d) / 8;\", segment.size, segment.unit);\n  } else {\n    $line('size = %d;', segment.size * segment.unit / 8);\n  }\n  $line('%s(buf, val, offset, size, %s);', writer, segment.bigendian);\n  $line('offset += size;');\n}\nfunction size_of(segments) {\n  var variable = [];\n  var fixed = 0;\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (typeof segment.size === 'string' || segment.size === true) {\n      variable.push(segment);\n    } else if (segment.type === 'string') {\n      fixed += Buffer.byteLength(segment.value);\n    } else {\n      fixed += segment.size * segment.unit / 8;\n    }\n  }\n  $line('var buffersize = %d;', fixed);\n  if (variable.length > 0) {\n    for (var j = 0; j < variable.length; j++) {\n      var segment = variable[j];\n      if (segment.size === true) {\n        $line(\"buffersize += bindings['%s'].length;\", segment.name);\n      } else {\n        $line(\"buffersize += (bindings['%s'] * %d) / 8;\", segment.size, segment.unit);\n      }\n    }\n  }\n}\nfunction emit_write(segments) {\n  $line('var val, size;');\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line('// %s', JSON.stringify(segment));\n    write_seg(segment);\n  }\n}\nfunction compile_ctor(segments) {\n  $start();\n  $line('return function(bindings) {');\n  $line(\"'use strict';\");\n  size_of(segments);\n  $line('var buf = new Buffer(buffersize);');\n  $line('var offset = 0;');\n  emit_write(segments);\n  $line('return buf;');\n  $line('}'); // end function\n\n  return new Function('write_int', 'write_float', $result())(write_int, write_float);\n}\nmodule.exports.compile_pattern = compile_pattern;\nmodule.exports.compile = function () {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_pattern(p);\n};\nmodule.exports.compile_builder = function () {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_ctor(p);\n};","map":{"version":3,"names":["require","$","format","parse","interp","parse_int","parse_float","construct","write_int","write_float","lines","$start","$line","push","apply","arguments","$result","join","bits_expr","segment","size","var_name","unit","toString","get_number","parser","type","be","bigendian","sg","signed","get_binary","get_string","strlen","value","length","strlenbits","skip_bits","bits","match_seg","name","assign_result","repr","JSON","stringify","variables","segments","names","i","Object","keys","compile_pattern","varnames","v","len","fn","Function","write_seg","write_number","writer","size_of","variable","fixed","Buffer","byteLength","j","emit_write","compile_ctor","module","exports","compile","str","call","p","compile_builder"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/bitsyntax/lib/compile.js"],"sourcesContent":["// Compile patterns to recognisers and constructors\n\n'use strict';\n\nrequire('buffer-more-ints');\nvar $ = require('util').format;\n\nvar parse = require('./parse').parse;\nvar interp = require('./interp'),\n  parse_int = interp.parse_int,\n  parse_float = interp.parse_float;\nvar construct = require('./constructor'),\n  write_int = construct.write_int,\n  write_float = construct.write_float;\n\nvar lines = [];\nfunction $start() {\n  lines = [];\n}\nfunction $line(/* format , args */) {\n  lines.push($.apply(null, arguments));\n}\nfunction $result() {\n  return lines.join('\\n');\n}\n\nfunction bits_expr(segment) {\n  if (typeof segment.size === 'string') {\n    return $('%s * %d', var_name(segment.size), segment.unit);\n  }\n  else {\n    return (segment.size * segment.unit).toString();\n  }\n}\n\nfunction get_number(segment) {\n  $line('bits = %s;\\n', bits_expr(segment));\n  var parser = (segment.type === 'integer') ?\n    'parse_int' : 'parse_float';\n  var be = segment.bigendian, sg = segment.signed;\n  $line(\"byteoffset = offset / 8; offset += bits\");\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = %s(bin, byteoffset, bits / 8, %s, %s); }\",\n        parser, be, sg);\n}\n\nfunction get_binary(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  if (segment.size === true) {\n    $line(\"offset = binsize;\");\n    $line(\"result = bin.slice(byteoffset);\");\n  }\n  else {\n    $line(\"bits = %s;\", bits_expr(segment));\n    $line(\"offset += bits;\");\n    $line(\"if (offset > binsize) { return false; }\");\n    $line(\"else { result = bin.slice(byteoffset,\",\n          \"byteoffset + bits / 8); }\");\n  }\n}\n\nfunction get_string(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  var strlen = segment.value.length;\n  var strlenbits = strlen * 8;\n  $line(\"offset += %d;\", strlenbits);\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = bin.toString(byteoffset,\",\n        $(\"byteoffset + %d); }\", strlen));\n}\n\nfunction skip_bits(segment) {\n  if (typeof segment.size === 'string') {\n    // Damn. Have to look up the size.\n    $line(\"var skipbits = %s * %d;\",\n          var_name(segment.size), segment.unit);\n    $line(\"if (offset + skipbits > binsize) { return false; }\");\n    $line(\"else { offset += skipbits; }\");\n  }\n  else if (segment.size === true) {\n    $line(\"if (offset % 8 === 0) { offset = binsize; }\");\n    $line(\"else { return false; }\");\n  }\n  else {\n    var bits = segment.unit * segment.size;\n    $line(\"if (offset + %d > binsize) { return false; }\", bits);\n    $line(\"else { offset += %d; }\", bits);\n  }\n}\n\nfunction match_seg(segment) {\n  if (segment.name === '_') {\n    skip_bits(segment);\n  }\n  else {\n    var assign_result;\n    switch (segment.type) {\n    case 'integer':\n    case 'float':\n      get_number(segment);\n      break;\n    case 'binary':\n      get_binary(segment);\n      break;\n    case 'string':\n      get_string(segment);\n      break;\n    }\n    $line(\"if (result === false) return false;\");\n    if (segment.name) {\n      // variable is given a value in the environment\n      $line(\"else if (%s !== undefined) {\", var_name(segment.name));\n      // .. and it is not the same as that matched\n      $line(\"if (%s != result) return false;\",\n            var_name(segment.name));\n      $line(\"}\");\n      // variable is free\n      $line('else %s = result;', var_name(segment.name));\n    }\n    else {\n      var repr = JSON.stringify(segment.value);\n      $line(\"else if (result != %s) return false;\", repr);\n    }\n  }\n}\n\nfunction var_name(name) {\n  return  'var_' + name;\n}\n\nfunction variables(segments) {\n  var names = {};\n  for (var i = 0; i < segments.length; i++) {\n    var name = segments[i].name;\n    if (name && name !== '_') {\n      names[name] = true;\n    }\n    name = segments[i].size;\n    if (typeof name === 'string') {\n      names[name] = true;\n    }\n  }\n  return Object.keys(names);\n}\n\nfunction compile_pattern(segments) {\n  $start();\n  $line(\"return function(binary, env) {\");\n  $line(\"'use strict';\");\n  $line(\"var bin = binary, env = env || {};\");\n  $line(\"var offset = 0, binsize = bin.length * 8;\");\n  $line(\"var bits, result, byteoffset;\");\n  var varnames = variables(segments);\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"var %s = env['%s'];\", var_name(name), name);\n  }\n\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line(\"// \" + JSON.stringify(segment));\n    match_seg(segment);\n  }\n\n  $line(\"if (offset == binsize) {\");\n  $line(\"return {\");\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"%s: %s,\", name, var_name(name));\n  }\n  $line('};');\n  $line('}'); // if offset == binsize\n  $line(\"else return false;\");\n  $line(\"}\"); // end function\n\n  var fn = new Function('parse_int', 'parse_float', $result());\n  return fn(parse_int, parse_float);\n}\n\n\nfunction write_seg(segment) {\n  switch (segment.type) {\n  case 'string':\n    $line(\"offset += buf.write(%s, offset, 'utf8');\",\n          JSON.stringify(segment.value));\n    break;\n  case 'binary':\n    $line(\"val = bindings['%s'];\", segment.name);\n    if (segment.size === true) {\n      $line('size = val.length;');\n    }\n    else if (typeof segment.size === 'string') {\n      $line(\"size = (bindings['%s'] * %d) / 8;\",\n            segment.size, segment.unit);\n    }\n    else {\n      $line(\"size = %d;\", (segment.size * segment.unit) / 8);\n    }\n    $line('val.copy(buf, offset, 0, size);');\n    $line('offset += size;');\n    break;\n  case 'integer':\n  case 'float':\n    write_number(segment);\n    break;\n  }\n}\n\nfunction write_number(segment) {\n  if (segment.name) {\n    $line(\"val = bindings['%s'];\", segment.name);\n  }\n  else {\n    $line(\"val = %d\", segment.value);\n  }\n  var writer = (segment.type === 'integer') ?\n    'write_int' : 'write_float';\n  if (typeof segment.size === 'string') {\n    $line(\"size = (bindings['%s'] * %d) / 8;\",\n          segment.size, segment.unit);\n  }\n  else {\n    $line('size = %d;', (segment.size * segment.unit) / 8);\n  }\n  $line('%s(buf, val, offset, size, %s);',\n        writer, segment.bigendian);\n  $line('offset += size;');\n}\n\nfunction size_of(segments) {\n  var variable = [];\n  var fixed = 0;\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (typeof segment.size === 'string' ||\n        segment.size === true) {\n      variable.push(segment);\n    }\n    else if (segment.type === 'string') {\n      fixed += Buffer.byteLength(segment.value);\n    }\n    else {\n      fixed += (segment.size * segment.unit) / 8;\n    }\n  }\n\n  $line('var buffersize = %d;', fixed);\n\n  if (variable.length > 0) {\n    for (var j = 0; j < variable.length; j++) {\n      var segment = variable[j];\n      if (segment.size === true) {\n        $line(\"buffersize += bindings['%s'].length;\", segment.name);\n      }\n      else {\n        $line(\"buffersize += (bindings['%s'] * %d) / 8;\",\n              segment.size, segment.unit);\n      }\n    }\n  }\n}\n\nfunction emit_write(segments) {\n  $line('var val, size;');\n\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line('// %s', JSON.stringify(segment));\n    write_seg(segment);\n  }\n}\n\nfunction compile_ctor(segments) {\n  $start();\n  $line('return function(bindings) {');\n  $line(\"'use strict';\");\n  size_of(segments);\n  $line('var buf = new Buffer(buffersize);');\n  $line('var offset = 0;');\n  emit_write(segments);\n  $line('return buf;');\n  $line('}'); // end function\n\n  return new Function('write_int', 'write_float',\n                      $result())(write_int, write_float);\n}\n\nmodule.exports.compile_pattern = compile_pattern;\nmodule.exports.compile = function() {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_pattern(p);\n};\nmodule.exports.compile_builder = function() {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_ctor(p);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}