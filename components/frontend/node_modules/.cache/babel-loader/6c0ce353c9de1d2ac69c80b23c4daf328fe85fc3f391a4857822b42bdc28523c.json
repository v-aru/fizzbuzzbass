{"ast":null,"code":"// -*- js-indent-level: 2 -*-\n// Constructing patterns\n\n'use strict';\n\nfunction set(values) {\n  var s = {};\n  for (var i in values) {\n    s[values[i]] = 1;\n  }\n  return s;\n}\n\n// Construct a segment bound to a variable, e.g., from a segment like\n// \"Len:32/unsigned-big\". `specifiers0` is an array.\nfunction variable(name, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {\n    name: name\n  };\n  segment.type = type_in(specifiers);\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\nmodule.exports.variable = variable;\nmodule.exports.rest = function () {\n  return variable('_', true, ['binary']);\n};\n\n// Construct a segment with a literal value, e.g., from a segment like\n// \"206\". `specifiers0` is an array.\n\nfunction value(val, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {\n    value: val\n  };\n  segment.type = type_in(specifiers);\n  // TODO check type v. value ..\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\nmodule.exports.value = value;\n\n// A string can appear as a literal, but it must appear without\n// specifiers.\nfunction string(val) {\n  return {\n    value: val,\n    type: 'string'\n  };\n}\nmodule.exports.string = string;\nvar TYPES = {\n  'integer': 1,\n  'binary': 1,\n  'float': 1\n};\nfunction type_in(specifiers) {\n  for (var t in specifiers) {\n    if (TYPES[t]) {\n      return t;\n    }\n  }\n  return 'integer';\n}\nfunction specs(segment, type, specifiers) {\n  switch (type) {\n    case 'integer':\n      segment.signed = signed_in(specifiers);\n    // fall through\n    case 'float':\n      segment.bigendian = endian_in(specifiers);\n    // fall through\n    default:\n      segment.unit = unit_in(specifiers, segment.type);\n  }\n  return segment;\n}\nfunction endian_in(specifiers) {\n  // default is big, but I have chosen true = bigendian\n  return !specifiers['little'];\n}\nfunction signed_in(specifiers) {\n  // this time I got it right; default is unsigned\n  return specifiers['signed'];\n}\nfunction unit_in(specifiers, type) {\n  for (var s in specifiers) {\n    if (s.substr(0, 5) == 'unit:') {\n      var unit = parseInt(s.substr(5));\n      // TODO check sane for type\n      return unit;\n    }\n  }\n  // OK defaults then\n  switch (type) {\n    case 'binary':\n      return 8;\n    case 'integer':\n    case 'float':\n      return 1;\n  }\n}\nfunction size_of(segment, type, size, unit) {\n  if (size !== undefined && size !== '') {\n    return size;\n  } else {\n    switch (type) {\n      case 'integer':\n        return 8;\n      case 'float':\n        return 64;\n      case 'binary':\n        return true;\n    }\n  }\n}","map":{"version":3,"names":["set","values","s","i","variable","name","size","specifiers0","specifiers","segment","type","type_in","specs","size_of","unit","module","exports","rest","value","val","string","TYPES","t","signed","signed_in","bigendian","endian_in","unit_in","substr","parseInt","undefined"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/bitsyntax/lib/pattern.js"],"sourcesContent":["// -*- js-indent-level: 2 -*-\n// Constructing patterns\n\n'use strict';\n\nfunction set(values) {\n  var s = {};\n  for (var i in values) {\n    s[values[i]] = 1;\n  }\n  return s;\n}\n\n// Construct a segment bound to a variable, e.g., from a segment like\n// \"Len:32/unsigned-big\". `specifiers0` is an array.\nfunction variable(name, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {name: name};\n  segment.type = type_in(specifiers);\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\n\nmodule.exports.variable = variable;\nmodule.exports.rest = function() {\n  return variable('_', true, ['binary']);\n}\n\n// Construct a segment with a literal value, e.g., from a segment like\n// \"206\". `specifiers0` is an array.\n\nfunction value(val, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {value: val};\n  segment.type = type_in(specifiers);\n  // TODO check type v. value ..\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\n\nmodule.exports.value = value;\n\n// A string can appear as a literal, but it must appear without\n// specifiers.\nfunction string(val) {\n  return {value: val, type: 'string'};\n}\nmodule.exports.string = string;\n\nvar TYPES = {'integer': 1, 'binary': 1, 'float': 1};\nfunction type_in(specifiers) {\n  for (var t in specifiers) {\n    if (TYPES[t]) { return t; }\n  }\n  return 'integer';\n}\n\nfunction specs(segment, type, specifiers) {\n  switch (type) {\n  case 'integer':\n    segment.signed = signed_in(specifiers);\n    // fall through\n  case 'float':\n    segment.bigendian = endian_in(specifiers);\n    // fall through\n  default:\n    segment.unit = unit_in(specifiers, segment.type);\n  }\n  return segment;\n}\n\nfunction endian_in(specifiers) {\n  // default is big, but I have chosen true = bigendian\n  return !specifiers['little'];\n}\n\nfunction signed_in(specifiers) {\n  // this time I got it right; default is unsigned\n  return specifiers['signed'];\n}\n\nfunction unit_in(specifiers, type) {\n  for (var s in specifiers) {\n    if (s.substr(0, 5) == 'unit:') {\n      var unit = parseInt(s.substr(5));\n      // TODO check sane for type\n      return unit;\n    }\n  }\n  // OK defaults then\n  switch (type) {\n  case 'binary':\n    return 8;\n  case 'integer':\n  case 'float':\n    return 1;\n  }\n}\n\nfunction size_of(segment, type, size, unit) {\n  if (size !== undefined && size !== '') {\n    return size;\n  }\n  else {\n    switch (type) {\n    case 'integer':\n      return 8;\n    case 'float':\n      return 64;\n    case 'binary':\n      return true;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}