{"ast":null,"code":"//\n//\n//\n\n// Channel machinery.\n\n'use strict';\n\nvar defs = require('./defs');\nvar closeMsg = require('./format').closeMessage;\nvar inspect = require('./format').inspect;\nvar methodName = require('./format').methodName;\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\nvar fmt = require('util').format;\nvar IllegalOperationError = require('./error').IllegalOperationError;\nvar stackCapture = require('./error').stackCapture;\nvar Buffer = require('safe-buffer').Buffer;\nfunction Channel(connection) {\n  EventEmitter.call(this);\n  this.connection = connection;\n  // for the presently outstanding RPC\n  this.reply = null;\n  // for the RPCs awaiting action\n  this.pending = [];\n  // for unconfirmed messages\n  this.lwm = 1; // the least, unconfirmed deliveryTag\n  this.unconfirmed = []; // rolling window of delivery callbacks\n  this.on('ack', this.handleConfirm.bind(this, function (cb) {\n    if (cb) cb(null);\n  }));\n  this.on('nack', this.handleConfirm.bind(this, function (cb) {\n    if (cb) cb(new Error('message nacked'));\n  }));\n  // message frame state machine\n  this.handleMessage = acceptDeliveryOrReturn;\n}\ninherits(Channel, EventEmitter);\nmodule.exports.Channel = Channel;\nmodule.exports.acceptMessage = acceptMessage;\nvar C = Channel.prototype;\nC.allocate = function () {\n  this.ch = this.connection.freshChannel(this);\n  return this;\n};\n\n// Incoming frames are either notifications of e.g., message delivery,\n// or replies to something we've sent. In general I deal with the\n// former by emitting an event, and with the latter by keeping a track\n// of what's expecting a reply.\n//\n// The AMQP specification implies that RPCs can't be pipelined; that\n// is, you can have only one outstanding RPC on a channel at a\n// time. Certainly that's what RabbitMQ and its clients assume. For\n// this reason, I buffer RPCs if the channel is already waiting for a\n// reply.\n\n// Just send the damn frame.\nC.sendImmediately = function (method, fields) {\n  return this.connection.sendMethod(this.ch, method, fields);\n};\n\n// Invariant: !this.reply -> pending.length == 0. That is, whenever we\n// clear a reply, we must send another RPC (and thereby fill\n// this.reply) if there is one waiting. The invariant relevant here\n// and in `accept`.\nC.sendOrEnqueue = function (method, fields, reply) {\n  if (!this.reply) {\n    // if no reply waiting, we can go\n    assert(this.pending.length === 0);\n    this.reply = reply;\n    this.sendImmediately(method, fields);\n  } else {\n    this.pending.push({\n      method: method,\n      fields: fields,\n      reply: reply\n    });\n  }\n};\nC.sendMessage = function (fields, properties, content) {\n  return this.connection.sendMessage(this.ch, defs.BasicPublish, fields, defs.BasicProperties, properties, content);\n};\n\n// Internal, synchronously resolved RPC; the return value is resolved\n// with the whole frame.\nC._rpc = function (method, fields, expect, cb) {\n  var self = this;\n  function reply(err, f) {\n    if (err === null) {\n      if (f.id === expect) {\n        return cb(null, f);\n      } else {\n        // We have detected a problem, so it's up to us to close the\n        // channel\n        var expectedName = methodName(expect);\n        var e = new Error(fmt(\"Expected %s; got %s\", expectedName, inspect(f, false)));\n        self.closeWithError(fmt('Expected %s; got %s', expectedName, methodName(f.id)), defs.constants.UNEXPECTED_FRAME, e);\n        return cb(e);\n      }\n    }\n    // An error will be given if, for example, this is waiting to be\n    // sent and the connection closes\n    else if (err instanceof Error) return cb(err);\n    // A close frame will be given if this is the RPC awaiting reply\n    // and the channel is closed by the server\n    else {\n      // otherwise, it's a close frame\n      var closeReason = (err.fields.classId << 16) + err.fields.methodId;\n      var e = method === closeReason ? fmt(\"Operation failed: %s; %s\", methodName(method), closeMsg(err)) : fmt(\"Channel closed by server: %s\", closeMsg(err));\n      return cb(new Error(e));\n    }\n  }\n  this.sendOrEnqueue(method, fields, reply);\n};\n\n// Shutdown protocol. There's three scenarios:\n//\n// 1. The application decides to shut the channel\n// 2. The server decides to shut the channel, possibly because of\n// something the application did\n// 3. The connection is closing, so there won't be any more frames\n// going back and forth.\n//\n// 1 and 2 involve an exchange of method frames (Close and CloseOk),\n// while 3 doesn't; the connection simply says \"shutdown\" to the\n// channel, which then acts as if it's closing, without going through\n// the exchange.\n\nfunction invalidOp(msg, stack) {\n  return function () {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\nfunction invalidateSend(ch, msg, stack) {\n  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage = invalidOp(msg, stack);\n}\n\n// Move to entirely closed state.\nC.toClosed = function (capturedStack) {\n  this._rejectPending();\n  invalidateSend(this, 'Channel closed', capturedStack);\n  this.accept = invalidOp('Channel closed', capturedStack);\n  this.connection.releaseChannel(this.ch);\n  this.emit('close');\n};\n\n// Stop being able to send and receive methods and content. Used when\n// we close the channel. Invokes the continuation once the server has\n// acknowledged the close, but before the channel is moved to the\n// closed state.\nC.toClosing = function (capturedStack, k) {\n  var send = this.sendImmediately.bind(this);\n  invalidateSend(this, 'Channel closing', capturedStack);\n  this.accept = function (f) {\n    if (f.id === defs.ChannelCloseOk) {\n      if (k) k();\n      var s = stackCapture('ChannelCloseOk frame received');\n      this.toClosed(s);\n    } else if (f.id === defs.ChannelClose) {\n      send(defs.ChannelCloseOk, {});\n    }\n    // else ignore frame\n  };\n};\nC._rejectPending = function () {\n  function rej(r) {\n    r(new Error(\"Channel ended, no reply will be forthcoming\"));\n  }\n  if (this.reply !== null) rej(this.reply);\n  this.reply = null;\n  var discard;\n  while (discard = this.pending.shift()) rej(discard.reply);\n  this.pending = null; // so pushes will break\n};\nC.closeBecause = function (reason, code, k) {\n  this.sendImmediately(defs.ChannelClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId: 0,\n    classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\n// If we close because there's been an error, we need to distinguish\n// between what we tell the server (`reason`) and what we report as\n// the cause in the client (`error`).\nC.closeWithError = function (reason, code, error) {\n  var self = this;\n  this.closeBecause(reason, code, function () {\n    error.code = code;\n    self.emit('error', error);\n  });\n};\n\n// A trampolining state machine for message frames on a channel. A\n// message arrives in at least two frames: first, a method announcing\n// the message (either a BasicDeliver or BasicGetOk); then, a message\n// header with the message properties; then, zero or more content\n// frames.\n\n// Keep the try/catch localised, in an attempt to avoid disabling\n// optimisation\nC.acceptMessageFrame = function (f) {\n  try {\n    this.handleMessage = this.handleMessage(f);\n  } catch (msg) {\n    if (typeof msg === 'string') {\n      this.closeWithError(msg, defs.constants.UNEXPECTED_FRAME, new Error(msg));\n    } else if (msg instanceof Error) {\n      this.closeWithError('Error while processing message', defs.constants.INTERNAL_ERROR, msg);\n    } else {\n      this.closeWithError('Internal error while processing message', defs.constants.INTERNAL_ERROR, new Error(msg.toString()));\n    }\n  }\n};\n\n// Kick off a message delivery given a BasicDeliver or BasicReturn\n// frame (BasicGet uses the RPC mechanism)\nfunction acceptDeliveryOrReturn(f) {\n  var event;\n  if (f.id === defs.BasicDeliver) event = 'delivery';else if (f.id === defs.BasicReturn) event = 'return';else throw fmt(\"Expected BasicDeliver or BasicReturn; got %s\", inspect(f));\n  var self = this;\n  var fields = f.fields;\n  return acceptMessage(function (message) {\n    message.fields = fields;\n    self.emit(event, message);\n  });\n}\n\n// Move to the state of waiting for message frames (headers, then\n// one or more content frames)\nfunction acceptMessage(continuation) {\n  var totalSize = 0,\n    remaining = 0;\n  var buffers = null;\n  var message = {\n    fields: null,\n    properties: null,\n    content: null\n  };\n  return headers;\n\n  // expect a headers frame\n  function headers(f) {\n    if (f.id === defs.BasicProperties) {\n      message.properties = f.fields;\n      totalSize = remaining = f.size;\n\n      // for zero-length messages, content frames aren't required.\n      if (totalSize === 0) {\n        message.content = Buffer.alloc(0);\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      } else {\n        return content;\n      }\n    } else {\n      throw \"Expected headers frame after delivery\";\n    }\n  }\n\n  // expect a content frame\n  // %%% TODO cancelled messages (sent as zero-length content frame)\n  function content(f) {\n    if (f.content) {\n      var size = f.content.length;\n      remaining -= size;\n      if (remaining === 0) {\n        if (buffers !== null) {\n          buffers.push(f.content);\n          message.content = Buffer.concat(buffers);\n        } else {\n          message.content = f.content;\n        }\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      } else if (remaining < 0) {\n        throw fmt(\"Too much content sent! Expected %d bytes\", totalSize);\n      } else {\n        if (buffers !== null) buffers.push(f.content);else buffers = [f.content];\n        return content;\n      }\n    } else throw \"Expected content frame after headers\";\n  }\n}\nC.handleConfirm = function (handle, f) {\n  var tag = f.deliveryTag;\n  var multi = f.multiple;\n  if (multi) {\n    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);\n    this.lwm = tag + 1;\n    confirmed.forEach(handle);\n  } else {\n    var c;\n    if (tag === this.lwm) {\n      c = this.unconfirmed.shift();\n      this.lwm++;\n      // Advance the LWM and the window to the next non-gap, or\n      // possibly to the end\n      while (this.unconfirmed[0] === null) {\n        this.unconfirmed.shift();\n        this.lwm++;\n      }\n    } else {\n      c = this.unconfirmed[tag - this.lwm];\n      this.unconfirmed[tag - this.lwm] = null;\n    }\n    // Technically, in the single-deliveryTag case, I should report a\n    // protocol breach if it's already been confirmed.\n    handle(c);\n  }\n};\nC.pushConfirmCallback = function (cb) {\n  // `null` is used specifically for marking already confirmed slots,\n  // so I coerce `undefined` and `null` to false; functions are never\n  // falsey.\n  this.unconfirmed.push(cb || false);\n};\n\n// Interface for connection to use\n\nC.accept = function (f) {\n  switch (f.id) {\n    // Message frames\n    case undefined: // content frame!\n    case defs.BasicDeliver:\n    case defs.BasicReturn:\n    case defs.BasicProperties:\n      return this.acceptMessageFrame(f);\n\n    // confirmations, need to do confirm.select first\n    case defs.BasicAck:\n      return this.emit('ack', f.fields);\n    case defs.BasicNack:\n      return this.emit('nack', f.fields);\n    case defs.BasicCancel:\n      // The broker can send this if e.g., the queue is deleted.\n      return this.emit('cancel', f.fields);\n    case defs.ChannelClose:\n      // Any remote closure is an error to us. Reject the pending reply\n      // with the close frame, so it can see whether it was that\n      // operation that caused it to close.\n      if (this.reply) {\n        var reply = this.reply;\n        this.reply = null;\n        reply(f);\n      }\n      var emsg = \"Channel closed by server: \" + closeMsg(f);\n      this.sendImmediately(defs.ChannelCloseOk, {});\n      var error = new Error(emsg);\n      error.code = f.fields.replyCode;\n      this.emit('error', error);\n      var s = stackCapture(emsg);\n      this.toClosed(s);\n      return;\n    case defs.BasicFlow:\n      // RabbitMQ doesn't send this, it just blocks the TCP socket\n      return this.closeWithError(\"Flow not implemented\", defs.constants.NOT_IMPLEMENTED, new Error('Flow not implemented'));\n    default:\n      // assume all other things are replies\n      // Resolving the reply may lead to another RPC; to make sure we\n      // don't hold that up, clear this.reply\n      var reply = this.reply;\n      this.reply = null;\n      // however, maybe there's an RPC waiting to go? If so, that'll\n      // fill this.reply again, restoring the invariant. This does rely\n      // on any response being recv'ed after resolving the promise,\n      // below; hence, I use synchronous defer.\n      if (this.pending.length > 0) {\n        var send = this.pending.shift();\n        this.reply = send.reply;\n        this.sendImmediately(send.method, send.fields);\n      }\n      return reply(null, f);\n  }\n};\nC.onBufferDrain = function () {\n  this.emit('drain');\n};\n\n// This adds just a bit more stuff useful for the APIs, but not\n// low-level machinery.\nfunction BaseChannel(connection) {\n  Channel.call(this, connection);\n  this.consumers = {};\n}\ninherits(BaseChannel, Channel);\nmodule.exports.BaseChannel = BaseChannel;\n\n// Not sure I like the ff, it's going to be changing hidden classes\n// all over the place. On the other hand, whaddya do.\nBaseChannel.prototype.registerConsumer = function (tag, callback) {\n  this.consumers[tag] = callback;\n};\nBaseChannel.prototype.unregisterConsumer = function (tag) {\n  delete this.consumers[tag];\n};\nBaseChannel.prototype.dispatchMessage = function (fields, message) {\n  var consumerTag = fields.consumerTag;\n  var consumer = this.consumers[consumerTag];\n  if (consumer) {\n    return consumer(message);\n  } else {\n    // %%% Surely a race here\n    throw new Error(\"Unknown consumer: \" + consumerTag);\n  }\n};\nBaseChannel.prototype.handleDelivery = function (message) {\n  return this.dispatchMessage(message.fields, message);\n};\nBaseChannel.prototype.handleCancel = function (fields) {\n  return this.dispatchMessage(fields, null);\n};","map":{"version":3,"names":["defs","require","closeMsg","closeMessage","inspect","methodName","assert","inherits","EventEmitter","fmt","format","IllegalOperationError","stackCapture","Buffer","Channel","connection","call","reply","pending","lwm","unconfirmed","on","handleConfirm","bind","cb","Error","handleMessage","acceptDeliveryOrReturn","module","exports","acceptMessage","C","prototype","allocate","ch","freshChannel","sendImmediately","method","fields","sendMethod","sendOrEnqueue","length","push","sendMessage","properties","content","BasicPublish","BasicProperties","_rpc","expect","self","err","f","id","expectedName","e","closeWithError","constants","UNEXPECTED_FRAME","closeReason","classId","methodId","invalidOp","msg","stack","invalidateSend","toClosed","capturedStack","_rejectPending","accept","releaseChannel","emit","toClosing","k","send","ChannelCloseOk","s","ChannelClose","rej","r","discard","shift","closeBecause","reason","code","replyText","replyCode","error","acceptMessageFrame","INTERNAL_ERROR","toString","event","BasicDeliver","BasicReturn","message","continuation","totalSize","remaining","buffers","headers","size","alloc","concat","handle","tag","deliveryTag","multi","multiple","confirmed","splice","forEach","c","pushConfirmCallback","undefined","BasicAck","BasicNack","BasicCancel","emsg","BasicFlow","NOT_IMPLEMENTED","onBufferDrain","BaseChannel","consumers","registerConsumer","callback","unregisterConsumer","dispatchMessage","consumerTag","consumer","handleDelivery","handleCancel"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/amqplib/lib/channel.js"],"sourcesContent":["//\n//\n//\n\n// Channel machinery.\n\n'use strict';\n\nvar defs = require('./defs');\nvar closeMsg = require('./format').closeMessage;\nvar inspect = require('./format').inspect;\nvar methodName = require('./format').methodName;\nvar assert = require('assert');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\nvar fmt = require('util').format;\nvar IllegalOperationError = require('./error').IllegalOperationError;\nvar stackCapture = require('./error').stackCapture;\nvar Buffer = require('safe-buffer').Buffer\nfunction Channel(connection) {\n  EventEmitter.call( this );\n  this.connection = connection;\n  // for the presently outstanding RPC\n  this.reply = null;\n  // for the RPCs awaiting action\n  this.pending = [];\n  // for unconfirmed messages\n  this.lwm = 1; // the least, unconfirmed deliveryTag\n  this.unconfirmed = []; // rolling window of delivery callbacks\n  this.on('ack', this.handleConfirm.bind(this, function(cb) {\n    if (cb) cb(null);\n  }));\n  this.on('nack', this.handleConfirm.bind(this, function(cb) {\n    if (cb) cb(new Error('message nacked'));\n  }));\n  // message frame state machine\n  this.handleMessage = acceptDeliveryOrReturn;\n}\ninherits(Channel, EventEmitter);\n\nmodule.exports.Channel = Channel;\nmodule.exports.acceptMessage = acceptMessage;\n\nvar C = Channel.prototype;\n\nC.allocate = function() {\n  this.ch = this.connection.freshChannel(this);\n  return this;\n}\n\n// Incoming frames are either notifications of e.g., message delivery,\n// or replies to something we've sent. In general I deal with the\n// former by emitting an event, and with the latter by keeping a track\n// of what's expecting a reply.\n//\n// The AMQP specification implies that RPCs can't be pipelined; that\n// is, you can have only one outstanding RPC on a channel at a\n// time. Certainly that's what RabbitMQ and its clients assume. For\n// this reason, I buffer RPCs if the channel is already waiting for a\n// reply.\n\n// Just send the damn frame.\nC.sendImmediately = function(method, fields) {\n  return this.connection.sendMethod(this.ch, method, fields);\n};\n\n// Invariant: !this.reply -> pending.length == 0. That is, whenever we\n// clear a reply, we must send another RPC (and thereby fill\n// this.reply) if there is one waiting. The invariant relevant here\n// and in `accept`.\nC.sendOrEnqueue = function(method, fields, reply) {\n  if (!this.reply) { // if no reply waiting, we can go\n    assert(this.pending.length === 0);\n    this.reply = reply;\n    this.sendImmediately(method, fields);\n  }\n  else {\n    this.pending.push({method: method,\n                       fields: fields,\n                       reply: reply});\n  }\n};\n\nC.sendMessage = function(fields, properties, content) {\n  return this.connection.sendMessage(\n    this.ch,\n    defs.BasicPublish, fields,\n    defs.BasicProperties, properties,\n    content);\n};\n\n// Internal, synchronously resolved RPC; the return value is resolved\n// with the whole frame.\nC._rpc = function(method, fields, expect, cb) {\n  var self = this;\n\n  function reply(err, f) {\n    if (err === null) {\n      if (f.id === expect) {\n        return cb(null, f);\n      }\n      else {\n        // We have detected a problem, so it's up to us to close the\n        // channel\n        var expectedName = methodName(expect);\n        var e = new Error(fmt(\"Expected %s; got %s\",\n                              expectedName, inspect(f, false)));\n        self.closeWithError(fmt('Expected %s; got %s',\n                                expectedName, methodName(f.id)),\n                            defs.constants.UNEXPECTED_FRAME, e);\n        return cb(e);\n      }\n    }\n    // An error will be given if, for example, this is waiting to be\n    // sent and the connection closes\n    else if (err instanceof Error) return cb(err);\n    // A close frame will be given if this is the RPC awaiting reply\n    // and the channel is closed by the server\n    else {\n      // otherwise, it's a close frame\n      var closeReason =\n        (err.fields.classId << 16) + err.fields.methodId;\n      var e = (method === closeReason)\n        ? fmt(\"Operation failed: %s; %s\",\n              methodName(method), closeMsg(err))\n        : fmt(\"Channel closed by server: %s\", closeMsg(err));\n      return cb(new Error(e));\n    }\n  }\n\n  this.sendOrEnqueue(method, fields, reply);\n};\n\n// Shutdown protocol. There's three scenarios:\n//\n// 1. The application decides to shut the channel\n// 2. The server decides to shut the channel, possibly because of\n// something the application did\n// 3. The connection is closing, so there won't be any more frames\n// going back and forth.\n//\n// 1 and 2 involve an exchange of method frames (Close and CloseOk),\n// while 3 doesn't; the connection simply says \"shutdown\" to the\n// channel, which then acts as if it's closing, without going through\n// the exchange.\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(ch, msg, stack) {\n  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage =\n    invalidOp(msg, stack);\n}\n\n// Move to entirely closed state.\nC.toClosed = function(capturedStack) {\n  this._rejectPending();\n  invalidateSend(this, 'Channel closed', capturedStack);\n  this.accept = invalidOp('Channel closed', capturedStack);\n  this.connection.releaseChannel(this.ch);\n  this.emit('close');\n};\n\n// Stop being able to send and receive methods and content. Used when\n// we close the channel. Invokes the continuation once the server has\n// acknowledged the close, but before the channel is moved to the\n// closed state.\nC.toClosing = function(capturedStack, k) {\n  var send = this.sendImmediately.bind(this);\n  invalidateSend(this, 'Channel closing', capturedStack);\n\n  this.accept = function(f) {\n    if (f.id === defs.ChannelCloseOk) {\n      if (k) k();\n      var s = stackCapture('ChannelCloseOk frame received');\n      this.toClosed(s);\n    }\n    else if (f.id === defs.ChannelClose) {\n      send(defs.ChannelCloseOk, {});\n    }\n    // else ignore frame\n  };\n};\n\nC._rejectPending = function() {\n  function rej(r) { \n    r(new Error(\"Channel ended, no reply will be forthcoming\"));\n  }\n  if (this.reply !== null) rej(this.reply);\n  this.reply = null;\n\n  var discard;\n  while (discard = this.pending.shift()) rej(discard.reply);\n  this.pending = null; // so pushes will break\n};\n\nC.closeBecause = function(reason, code, k) {\n  this.sendImmediately(defs.ChannelClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId:0, classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\n// If we close because there's been an error, we need to distinguish\n// between what we tell the server (`reason`) and what we report as\n// the cause in the client (`error`).\nC.closeWithError = function(reason, code, error) {\n  var self = this;\n  this.closeBecause(reason, code, function() {\n    error.code = code;\n    self.emit('error', error);\n  });\n};\n\n// A trampolining state machine for message frames on a channel. A\n// message arrives in at least two frames: first, a method announcing\n// the message (either a BasicDeliver or BasicGetOk); then, a message\n// header with the message properties; then, zero or more content\n// frames.\n\n// Keep the try/catch localised, in an attempt to avoid disabling\n// optimisation\nC.acceptMessageFrame = function(f) {\n  try {\n    this.handleMessage = this.handleMessage(f);\n  }\n  catch (msg) {\n    if (typeof msg === 'string') {\n      this.closeWithError(msg, defs.constants.UNEXPECTED_FRAME,\n                          new Error(msg));\n    }\n    else if (msg instanceof Error) {\n      this.closeWithError('Error while processing message',\n                          defs.constants.INTERNAL_ERROR, msg);\n    }\n    else {\n      this.closeWithError('Internal error while processing message',\n                          defs.constants.INTERNAL_ERROR,\n                          new Error(msg.toString()));\n    }\n  }\n};\n\n// Kick off a message delivery given a BasicDeliver or BasicReturn\n// frame (BasicGet uses the RPC mechanism)\nfunction acceptDeliveryOrReturn(f) {\n  var event;\n  if (f.id === defs.BasicDeliver) event = 'delivery';\n  else if (f.id === defs.BasicReturn) event = 'return';\n  else throw fmt(\"Expected BasicDeliver or BasicReturn; got %s\",\n                 inspect(f));\n\n  var self = this;\n  var fields = f.fields;\n  return acceptMessage(function(message) {\n    message.fields = fields;\n    self.emit(event, message);\n  });\n}\n\n// Move to the state of waiting for message frames (headers, then\n// one or more content frames)\nfunction acceptMessage(continuation) {\n  var totalSize = 0, remaining = 0;\n  var buffers = null;\n\n  var message = {\n    fields: null,\n    properties: null,\n    content: null\n  };\n\n  return headers;\n\n  // expect a headers frame\n  function headers(f) {\n    if (f.id === defs.BasicProperties) {\n      message.properties = f.fields;\n      totalSize = remaining = f.size;\n      \n      // for zero-length messages, content frames aren't required.\n      if (totalSize === 0) {\n        message.content = Buffer.alloc(0);\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else {\n        return content;        \n      }\n    }\n    else {\n      throw \"Expected headers frame after delivery\";\n    }\n  }\n\n  // expect a content frame\n  // %%% TODO cancelled messages (sent as zero-length content frame)\n  function content(f) {\n    if (f.content) {\n      var size = f.content.length;\n      remaining -= size;\n      if (remaining === 0) {\n        if (buffers !== null) {\n          buffers.push(f.content);\n          message.content = Buffer.concat(buffers);\n        }\n        else {\n          message.content = f.content;\n        }\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else if (remaining < 0) {\n        throw fmt(\"Too much content sent! Expected %d bytes\",\n                  totalSize);\n      }\n      else {\n        if (buffers !== null)\n          buffers.push(f.content);\n        else\n          buffers = [f.content];\n        return content;\n      }\n    }\n    else throw \"Expected content frame after headers\"\n  }\n}\n\nC.handleConfirm = function(handle, f) {\n  var tag = f.deliveryTag;\n  var multi = f.multiple;\n\n  if (multi) {\n    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);\n    this.lwm = tag + 1;\n    confirmed.forEach(handle);\n  }\n  else {\n    var c;\n    if (tag === this.lwm) {\n      c = this.unconfirmed.shift();\n      this.lwm++;\n      // Advance the LWM and the window to the next non-gap, or\n      // possibly to the end\n      while (this.unconfirmed[0] === null) {\n        this.unconfirmed.shift();\n        this.lwm++;\n      }\n    }\n    else {\n      c = this.unconfirmed[tag - this.lwm];\n      this.unconfirmed[tag - this.lwm] = null;\n    }\n    // Technically, in the single-deliveryTag case, I should report a\n    // protocol breach if it's already been confirmed.\n    handle(c);\n  }\n};\n\nC.pushConfirmCallback = function(cb) {\n  // `null` is used specifically for marking already confirmed slots,\n  // so I coerce `undefined` and `null` to false; functions are never\n  // falsey.\n  this.unconfirmed.push(cb || false);\n};\n\n// Interface for connection to use\n\nC.accept = function(f) {\n\n  switch (f.id) {\n\n    // Message frames\n  case undefined: // content frame!\n  case defs.BasicDeliver:\n  case defs.BasicReturn:\n  case defs.BasicProperties:\n    return this.acceptMessageFrame(f);\n\n    // confirmations, need to do confirm.select first\n  case defs.BasicAck:\n    return this.emit('ack', f.fields);\n  case defs.BasicNack:\n    return this.emit('nack', f.fields);\n  case defs.BasicCancel:\n    // The broker can send this if e.g., the queue is deleted.\n    return this.emit('cancel', f.fields);\n\n  case defs.ChannelClose:\n    // Any remote closure is an error to us. Reject the pending reply\n    // with the close frame, so it can see whether it was that\n    // operation that caused it to close.\n    if (this.reply) {\n      var reply = this.reply; this.reply = null;\n      reply(f);\n    }\n    var emsg = \"Channel closed by server: \" + closeMsg(f);\n    this.sendImmediately(defs.ChannelCloseOk, {});\n\n    var error = new Error(emsg);\n    error.code = f.fields.replyCode;\n    this.emit('error', error);\n\n    var s = stackCapture(emsg);\n    this.toClosed(s);\n    return;\n\n  case defs.BasicFlow:\n    // RabbitMQ doesn't send this, it just blocks the TCP socket\n    return this.closeWithError(\"Flow not implemented\",\n                               defs.constants.NOT_IMPLEMENTED,\n                               new Error('Flow not implemented'));\n\n  default: // assume all other things are replies\n    // Resolving the reply may lead to another RPC; to make sure we\n    // don't hold that up, clear this.reply\n    var reply = this.reply; this.reply = null;\n    // however, maybe there's an RPC waiting to go? If so, that'll\n    // fill this.reply again, restoring the invariant. This does rely\n    // on any response being recv'ed after resolving the promise,\n    // below; hence, I use synchronous defer.\n    if (this.pending.length > 0) {\n      var send = this.pending.shift();\n      this.reply = send.reply;\n      this.sendImmediately(send.method, send.fields);\n    }\n    return reply(null, f);\n  }\n};\n\nC.onBufferDrain = function() {\n  this.emit('drain');\n};\n\n\n// This adds just a bit more stuff useful for the APIs, but not\n// low-level machinery.\nfunction BaseChannel(connection) {\n  Channel.call(this, connection);\n  this.consumers = {};\n}\ninherits(BaseChannel, Channel);\n\nmodule.exports.BaseChannel = BaseChannel;\n\n// Not sure I like the ff, it's going to be changing hidden classes\n// all over the place. On the other hand, whaddya do.\nBaseChannel.prototype.registerConsumer = function(tag, callback) {\n  this.consumers[tag] = callback;\n};\n\nBaseChannel.prototype.unregisterConsumer = function(tag) {\n  delete this.consumers[tag];\n};\n\nBaseChannel.prototype.dispatchMessage = function(fields, message) {\n  var consumerTag = fields.consumerTag;\n  var consumer = this.consumers[consumerTag];\n  if (consumer) {\n    return consumer(message);\n  }\n  else {\n    // %%% Surely a race here\n    throw new Error(\"Unknown consumer: \" + consumerTag);\n  }\n};\n\nBaseChannel.prototype.handleDelivery = function(message) {\n  return this.dispatchMessage(message.fields, message);\n};\n\nBaseChannel.prototype.handleCancel = function(fields) {\n  return this.dispatchMessage(fields, null);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}