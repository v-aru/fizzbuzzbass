{"ast":null,"code":"'use strict';\n\nvar token = require('./token'),\n  timeSafeCompare = require('tsscmp');\n\n/**\n * CSRF\n * https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)\n * @param {Object} options\n *    key {String} The name of the CSRF token in the model. Default \"_csrf\".\n *    impl {Object} An object with create/validate methods for custom tokens. Optional.\n *    header {String} The name of the response header containing the CSRF token. Default \"x-csrf-token\".\n */\nmodule.exports = function (options) {\n  var impl, key, header, secret, cookie, whitelist, blacklist;\n  options = options || {};\n  if (options.angular) {\n    options.header = 'X-XSRF-TOKEN';\n    options.cookie = {\n      name: 'XSRF-TOKEN',\n      options: options.cookie && options.cookie.options\n    };\n  }\n  whitelist = options.whitelist;\n  if (typeof whitelist === 'string') {\n    whitelist = [whitelist];\n  } else if (!Array.isArray(whitelist)) {\n    // Don't allow non string or array whitelist\n    whitelist = null;\n  }\n  blacklist = options.blacklist;\n  if (typeof blacklist === 'string') {\n    blacklist = [blacklist];\n  } else if (!Array.isArray(blacklist)) {\n    // Don't allow non string or array blacklist\n    blacklist = null;\n  }\n  key = options.key || '_csrf';\n  impl = options.impl || token;\n  header = options.header || 'x-csrf-token';\n  secret = options.secret || '_csrfSecret';\n\n  // Check if cookie is string or object\n  if (typeof options.cookie === 'string') {\n    cookie = {\n      name: options.cookie\n    };\n  } else {\n    cookie = {\n      name: options.cookie && options.cookie.name\n    };\n  }\n\n  // Set cookie options\n  cookie.options = options.cookie && options.cookie.options || {};\n  function getCsrf(req, secret) {\n    var _impl, validate, _token, _secret;\n    _impl = impl.create(req, secret);\n    validate = impl.validate || _impl.validate;\n    _token = _impl.token || _impl;\n    _secret = _impl.secret;\n    return {\n      validate: validate,\n      token: _token,\n      secret: _secret\n    };\n  }\n  function setToken(res, token) {\n    res.locals[key] = token;\n    if (cookie && cookie.name) {\n      res.cookie(cookie.name, token, cookie.options || {});\n    }\n  }\n  return function checkCsrf(req, res, next) {\n    var shouldBypass = false;\n    if (blacklist) {\n      blacklist.some(function (exclusion) {\n        shouldBypass = req.path.indexOf(exclusion) === 0;\n        return shouldBypass;\n      });\n    }\n    if (whitelist) {\n      whitelist.some(function (inclusion) {\n        shouldBypass = req.path.indexOf(inclusion) !== 0;\n        return shouldBypass;\n      });\n    }\n    if (shouldBypass) {\n      return next();\n    }\n    var method, _token, errmsg;\n    var csrf = getCsrf(req, secret);\n    setToken(res, csrf.token);\n    req.csrfToken = function csrfToken() {\n      var newCsrf = getCsrf(req, secret);\n      if (csrf.secret && newCsrf.secret && timeSafeCompare(csrf.secret, newCsrf.secret)) {\n        return csrf.token;\n      }\n      csrf = newCsrf;\n      setToken(res, csrf.token);\n      return csrf.token;\n    };\n\n    // Move along for safe verbs\n    method = req.method;\n    if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS') {\n      return next();\n    }\n\n    // Validate token\n    _token = req.body && req.body[key] || req.headers[header.toLowerCase()];\n    if (csrf.validate(req, _token)) {\n      next();\n    } else {\n      res.statusCode = 403;\n      if (!_token) {\n        errmsg = 'CSRF token missing';\n      } else {\n        errmsg = 'CSRF token mismatch';\n      }\n      next(new Error(errmsg));\n    }\n  };\n};","map":{"version":3,"names":["token","require","timeSafeCompare","module","exports","options","impl","key","header","secret","cookie","whitelist","blacklist","angular","name","Array","isArray","getCsrf","req","_impl","validate","_token","_secret","create","setToken","res","locals","checkCsrf","next","shouldBypass","some","exclusion","path","indexOf","inclusion","method","errmsg","csrf","csrfToken","newCsrf","body","headers","toLowerCase","statusCode","Error"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/lusca/lib/csrf.js"],"sourcesContent":["'use strict';\n\n\nvar token = require('./token'),\n    timeSafeCompare = require('tsscmp');\n\n\n/**\n * CSRF\n * https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)\n * @param {Object} options\n *    key {String} The name of the CSRF token in the model. Default \"_csrf\".\n *    impl {Object} An object with create/validate methods for custom tokens. Optional.\n *    header {String} The name of the response header containing the CSRF token. Default \"x-csrf-token\".\n */\nmodule.exports = function (options) {\n    var impl, key, header, secret, cookie, whitelist, blacklist;\n\n    options = options || {};\n\n    if (options.angular) {\n        options.header = 'X-XSRF-TOKEN';\n        options.cookie = {\n            name: 'XSRF-TOKEN',\n            options: options.cookie && options.cookie.options\n        };\n    }\n\n    whitelist = options.whitelist;\n\n    if (typeof whitelist === 'string') {\n        whitelist = [ whitelist ];\n    } else if (!Array.isArray(whitelist)) {\n        // Don't allow non string or array whitelist\n        whitelist = null;\n    }\n\n    blacklist = options.blacklist;\n\n    if (typeof blacklist === 'string') {\n        blacklist = [ blacklist ];\n    } else if (!Array.isArray(blacklist)) {\n        // Don't allow non string or array blacklist\n        blacklist = null;\n    }\n\n    key = options.key || '_csrf';\n    impl = options.impl || token;\n    header = options.header || 'x-csrf-token';\n    secret = options.secret || '_csrfSecret';\n\n    // Check if cookie is string or object\n    if (typeof options.cookie === 'string') {\n        cookie = {\n            name: options.cookie,\n        };\n    } else {\n        cookie = {\n            name: options.cookie && options.cookie.name\n        };\n    }\n\n    // Set cookie options\n    cookie.options = options.cookie && options.cookie.options || {};\n\n    function getCsrf(req, secret) {\n        var _impl, validate, _token, _secret;\n\n        _impl = impl.create(req, secret);\n        validate = impl.validate || _impl.validate;\n        _token = _impl.token || _impl;\n        _secret = _impl.secret;\n\n        return {\n            validate: validate,\n            token: _token,\n            secret: _secret\n        };\n    }\n\n    function setToken(res, token) {\n        res.locals[key] = token;\n\n        if (cookie && cookie.name) {\n            res.cookie(cookie.name, token, cookie.options || {});\n        }\n    }\n\n\n    return function checkCsrf(req, res, next) {\n\n        var shouldBypass = false;\n\n        if (blacklist) {\n            blacklist.some(function (exclusion) {\n                shouldBypass = req.path.indexOf(exclusion) === 0;\n                return shouldBypass;\n            });\n        }\n\n        if (whitelist) {\n            whitelist.some(function (inclusion) {\n                shouldBypass = req.path.indexOf(inclusion) !== 0;\n                return shouldBypass;\n            });\n        }\n\n        if (shouldBypass) {\n            return next();\n        }\n\n        var method, _token, errmsg;\n\n        var csrf = getCsrf(req, secret);\n\n        setToken(res, csrf.token);\n\n        req.csrfToken = function csrfToken() {\n            var newCsrf = getCsrf(req, secret);\n            if (csrf.secret && newCsrf.secret &&\n                timeSafeCompare(csrf.secret, newCsrf.secret)) {\n                return csrf.token;\n            }\n\n            csrf = newCsrf;\n            setToken(res, csrf.token);\n            return csrf.token;\n        };\n\n        // Move along for safe verbs\n        method = req.method;\n\n        if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS') {\n            return next();\n        }\n\n        // Validate token\n        _token = (req.body && req.body[key]) || req.headers[header.toLowerCase()];\n\n        if (csrf.validate(req, _token)) {\n            next();\n        } else {\n            res.statusCode = 403;\n\n            if (!_token) {\n                errmsg = 'CSRF token missing';\n            } else {\n                errmsg = 'CSRF token mismatch';\n            }\n\n            next(new Error(errmsg));\n        }\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}