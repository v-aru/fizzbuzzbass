{"ast":null,"code":"// -*- js-indent: 2 -*-\n// Interpreter for bit syntax AST.\n// Grammar:\n//\n// pattern   := segment (\",\" segment)*\n// segment   := (value | var) (\":\" size)? (\"/\" specifier (\"-\" specifier)*)? | string\n// var       := \"_\" | identifier\n// size      := integer | var\n// specifier := \"little\" | \"big\" | \"signed\" | \"unsigned\" | \"unit\" \":\" 0..256 | type\n// type      := \"integer\" | \"binary\" | \"float\"\n//\n// where integer has the obvious meaning, and identifier is anything\n// other than \"_\" that fits the JavaScript identifier specification.\n//\n\n// We'll use an object to represent each segment, and an array of\n// segments for a pattern. We won't try to optimise for groups of\n// patterns; we'll just step through each to see if it works. We rely\n// a hypothetical prior step to check that it's a valid pattern.\n\n// ? compile to intermediate instructions ?\n\n// A segment looks like\n// {\n//    type: string, // 'string' is special case\n//    size: integer | true, // true means 'all remaining'\n//    name: string | null, // (may be '_')\n//    value: value | null, // either name OR value\n//    unit: integer,\n//    signed: boolean,\n//    bigendian: boolean\n// }\n\n'use strict';\n\nvar ints = require('buffer-more-ints');\nvar debug = process.env.DEBUG ? function (s) {\n  console.log(s);\n} : function () {};\nfunction parse_int(bin, off, sizeInBytes, bigendian, signed) {\n  switch (sizeInBytes) {\n    case 1:\n      return signed ? bin.readInt8(off) : bin.readUInt8(off);\n    case 2:\n      return bigendian ? signed ? bin.readInt16BE(off) : bin.readUInt16BE(off) : signed ? bin.readInt16LE(off) : bin.readUInt16LE(off);\n    case 4:\n      return bigendian ? signed ? bin.readInt32BE(off) : bin.readUInt32BE(off) : signed ? bin.readInt32LE(off) : bin.readUInt32LE(off);\n    case 8:\n      return bigendian ? (signed ? ints.readInt64BE : ints.readUInt64BE)(bin, off) : (signed ? ints.readInt64LE : ints.readUInt64LE)(bin, off);\n    default:\n      throw \"Integers must be 8-, 16-, 32- or 64-bit\";\n  }\n}\nfunction parse_float(bin, off, sizeInBytes, bigendian) {\n  switch (sizeInBytes) {\n    case 4:\n      return bigendian ? bin.readFloatBE(off) : bin.readFloatLE(off);\n    case 8:\n      return bigendian ? bin.readDoubleBE(off) : bin.readDoubleLE(off);\n    default:\n      throw \"Floats must be 32- or 64-bit\";\n  }\n}\nfunction size_of(segment, bound) {\n  var size = segment.size;\n  if (typeof size === 'string') {\n    return bound[size];\n  } else {\n    return size;\n  }\n}\nfunction new_scope(env) {\n  function scope() {}\n  ;\n  scope.prototype = env;\n  return new scope();\n}\nfunction bindings(scope) {\n  var s = {};\n  for (var k in scope) {\n    if (scope.hasOwnProperty(k)) {\n      s[k] = scope[k];\n    }\n  }\n  return s;\n}\nfunction match(pattern, binary, boundvars) {\n  var offset = 0,\n    vars = new_scope(boundvars);\n  var binsize = binary.length * 8;\n  function skip_bits(segment) {\n    debug(\"skip bits\");\n    debug(segment);\n    var size = size_of(segment, vars);\n    if (size === true) {\n      if (offset % 8 === 0) {\n        offset = binsize;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    var bits = segment.unit * size;\n    if (offset + bits > binsize) {\n      return false;\n    } else {\n      offset += bits;\n    }\n  }\n  function get_integer(segment) {\n    debug(\"get_integer\");\n    debug(segment);\n    // let's do only multiples of eight bits for now\n    var unit = segment.unit,\n      size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // NB assumes aligned\n    offset += bitsize;\n    if (bitsize % 8 > 0 || offset > binsize) {\n      return false;\n    } else {\n      return parse_int(binary, byteoffset, bitsize / 8, segment.bigendian, segment.signed);\n    }\n  }\n  function get_float(segment) {\n    debug(\"get_float\");\n    debug(segment);\n    var unit = segment.unit;\n    var size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // assume aligned\n    offset += bitsize;\n    if (offset > binsize) {\n      return false;\n    } else {\n      return parse_float(binary, byteoffset, bitsize / 8, segment.bigendian);\n    }\n  }\n  function get_binary(segment) {\n    debug(\"get_binary\");\n    debug(segment);\n    var unit = segment.unit,\n      size = size_of(segment, vars);\n    var byteoffset = offset / 8; // NB alignment\n\n    if (size === true) {\n      offset = binsize;\n      return binary.slice(byteoffset);\n    } else {\n      var bitsize = size * unit;\n      if (bitsize % 8 > 0 || offset + bitsize > binsize) {\n        return false;\n      } else {\n        offset += bitsize;\n        return binary.slice(byteoffset, byteoffset + bitsize / 8);\n      }\n    }\n  }\n  function get_string(segment) {\n    debug(\"get_string\");\n    debug(segment);\n    var len = segment.value.length;\n    var byteoffset = offset / 8;\n    offset += len * 8;\n    if (offset > binsize) {\n      return false;\n    }\n    // FIXME bytes vs UTF8 characters\n    return binary.slice(byteoffset, byteoffset + len).toString('utf8');\n  }\n  var patternlen = pattern.length;\n  for (var i = 0; i < patternlen; i++) {\n    var segment = pattern[i];\n    var result = false;\n    if (segment.name === '_') {\n      result = skip_bits(segment);\n    } else {\n      switch (segment.type) {\n        case 'string':\n          result = get_string(segment);\n          break;\n        case 'integer':\n          result = get_integer(segment);\n          break;\n        case 'float':\n          result = get_float(segment);\n          break;\n        case 'binary':\n          result = get_binary(segment);\n          break;\n      }\n      if (result === false) {\n        return false;\n      } else if (segment.name) {\n        vars[segment.name] = result;\n      } else if (segment.value != result) {\n        return false;\n      }\n    }\n  }\n  if (offset == binsize) {\n    return bindings(vars);\n  } else {\n    return false;\n  }\n}\nmodule.exports.match = match;\nmodule.exports.parse_int = parse_int;\nmodule.exports.parse_float = parse_float;","map":{"version":3,"names":["ints","require","debug","process","env","DEBUG","s","console","log","parse_int","bin","off","sizeInBytes","bigendian","signed","readInt8","readUInt8","readInt16BE","readUInt16BE","readInt16LE","readUInt16LE","readInt32BE","readUInt32BE","readInt32LE","readUInt32LE","readInt64BE","readUInt64BE","readInt64LE","readUInt64LE","parse_float","readFloatBE","readFloatLE","readDoubleBE","readDoubleLE","size_of","segment","bound","size","new_scope","scope","prototype","bindings","k","hasOwnProperty","match","pattern","binary","boundvars","offset","vars","binsize","length","skip_bits","bits","unit","get_integer","bitsize","byteoffset","get_float","get_binary","slice","get_string","len","value","toString","patternlen","i","result","name","type","module","exports"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/bitsyntax/lib/interp.js"],"sourcesContent":["// -*- js-indent: 2 -*-\n// Interpreter for bit syntax AST.\n// Grammar:\n//\n// pattern   := segment (\",\" segment)*\n// segment   := (value | var) (\":\" size)? (\"/\" specifier (\"-\" specifier)*)? | string\n// var       := \"_\" | identifier\n// size      := integer | var\n// specifier := \"little\" | \"big\" | \"signed\" | \"unsigned\" | \"unit\" \":\" 0..256 | type\n// type      := \"integer\" | \"binary\" | \"float\"\n//\n// where integer has the obvious meaning, and identifier is anything\n// other than \"_\" that fits the JavaScript identifier specification.\n//\n\n// We'll use an object to represent each segment, and an array of\n// segments for a pattern. We won't try to optimise for groups of\n// patterns; we'll just step through each to see if it works. We rely\n// a hypothetical prior step to check that it's a valid pattern.\n\n// ? compile to intermediate instructions ?\n\n// A segment looks like\n// {\n//    type: string, // 'string' is special case\n//    size: integer | true, // true means 'all remaining'\n//    name: string | null, // (may be '_')\n//    value: value | null, // either name OR value\n//    unit: integer,\n//    signed: boolean,\n//    bigendian: boolean\n// }\n\n'use strict';\n\nvar ints = require('buffer-more-ints');\n\nvar debug = (process.env.DEBUG) ?\n  function(s) { console.log(s); } : function () {};\n\nfunction parse_int(bin, off, sizeInBytes, bigendian, signed) {\n  switch (sizeInBytes) {\n  case 1:\n    return (signed) ? bin.readInt8(off) : bin.readUInt8(off);\n  case 2:\n    return (bigendian) ?\n      (signed) ? bin.readInt16BE(off) : bin.readUInt16BE(off) :\n      (signed) ? bin.readInt16LE(off) : bin.readUInt16LE(off);\n  case 4:\n    return (bigendian) ?\n      (signed) ? bin.readInt32BE(off) : bin.readUInt32BE(off) :\n      (signed) ? bin.readInt32LE(off) : bin.readUInt32LE(off);\n  case 8:\n    return (bigendian) ?\n      ((signed) ? ints.readInt64BE : ints.readUInt64BE)(bin, off) :\n      ((signed) ? ints.readInt64LE : ints.readUInt64LE)(bin, off);\n  default:\n    throw \"Integers must be 8-, 16-, 32- or 64-bit\";\n  }\n}\n\nfunction parse_float(bin, off, sizeInBytes, bigendian) {\n  switch (sizeInBytes) {\n  case 4:\n    return (bigendian) ? bin.readFloatBE(off) : bin.readFloatLE(off);\n  case 8:\n    return (bigendian) ? bin.readDoubleBE(off) : bin.readDoubleLE(off);\n  default:\n    throw \"Floats must be 32- or 64-bit\";\n  }\n}\n\nfunction size_of(segment, bound) {\n  var size = segment.size;\n  if (typeof size === 'string') {\n    return bound[size];\n  }\n  else {\n    return size;\n  }\n}\n\nfunction new_scope(env) {\n  function scope() {};\n  scope.prototype = env;\n  return new scope();\n}\n\nfunction bindings(scope) {\n  var s = {};\n  for (var k in scope) {\n    if (scope.hasOwnProperty(k)) {\n      s[k] = scope[k];\n    }\n  }\n  return s;\n}\n\nfunction match(pattern, binary, boundvars) {\n  var offset = 0, vars = new_scope(boundvars);\n  var binsize = binary.length * 8;\n\n  function skip_bits(segment) {\n    debug(\"skip bits\"); debug(segment);\n    var size = size_of(segment, vars);\n    if (size === true) {\n      if (offset % 8 === 0) {\n        offset = binsize;\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n\n    var bits = segment.unit * size;\n    if (offset + bits > binsize) {\n      return false;\n    }\n    else {\n      offset += bits;\n    }\n  }\n\n  function get_integer(segment) {\n    debug(\"get_integer\"); debug(segment);\n    // let's do only multiples of eight bits for now\n    var unit = segment.unit, size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // NB assumes aligned\n    offset += bitsize;\n    if (bitsize % 8 > 0 || (offset > binsize)) {\n      return false;\n    }\n    else {\n      return parse_int(binary, byteoffset, bitsize / 8,\n                       segment.bigendian, segment.signed);\n    }\n  }\n\n  function get_float(segment) {\n    debug(\"get_float\"); debug(segment);\n    var unit = segment.unit; var size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // assume aligned\n    offset += bitsize;\n    if (offset > binsize) {\n      return false;\n    }\n    else {\n      return parse_float(binary, byteoffset,\n                         bitsize / 8, segment.bigendian);\n    }\n  }\n\n  function get_binary(segment) {\n    debug(\"get_binary\"); debug(segment);\n    var unit = segment.unit, size = size_of(segment, vars);\n    var byteoffset = offset / 8; // NB alignment\n\n    if (size === true) {\n      offset = binsize;\n      return binary.slice(byteoffset);\n    }\n    else {\n      var bitsize = size * unit;\n      if (bitsize % 8 > 0 || (offset + bitsize) > binsize) {\n        return false;\n      }\n      else {\n        offset += bitsize;\n        return binary.slice(byteoffset, byteoffset + bitsize / 8);\n      }\n    }\n  }\n\n  function get_string(segment) {\n    debug(\"get_string\"); debug(segment);\n    var len = segment.value.length;\n    var byteoffset = offset / 8;\n\n    offset += len * 8;\n    if (offset > binsize) {\n      return false;\n    }\n    // FIXME bytes vs UTF8 characters\n    return binary.slice(byteoffset, byteoffset + len).toString('utf8');\n  }\n\n  var patternlen = pattern.length;\n  for (var i = 0;  i < patternlen; i++) {\n    var segment = pattern[i];\n    var result = false;\n    if (segment.name === '_') {\n      result = skip_bits(segment);\n    }\n    else {\n      switch (segment.type) {\n      case 'string':\n        result = get_string(segment);\n        break;\n      case 'integer':\n        result = get_integer(segment);\n        break;\n      case 'float':\n        result = get_float(segment);\n        break;\n      case 'binary':\n        result = get_binary(segment);\n        break;\n      }\n\n      if (result === false) {\n        return false;\n      }\n      else if (segment.name) {\n        vars[segment.name] = result;\n      }\n      else if (segment.value != result) {\n        return false;\n      }\n    }\n  }\n  if (offset == binsize) {\n    return bindings(vars);\n  }\n  else {\n    return false;\n  }\n}\n\nmodule.exports.match = match;\nmodule.exports.parse_int = parse_int;\nmodule.exports.parse_float = parse_float;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}