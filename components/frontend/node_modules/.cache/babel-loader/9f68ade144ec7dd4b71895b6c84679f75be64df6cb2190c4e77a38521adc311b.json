{"ast":null,"code":"//\n//\n//\n\n/*\n\nThe AMQP 0-9-1 is a mess when it comes to the types that can be\nencoded on the wire.\n\nThere are four encoding schemes, and three overlapping sets of types:\nframes, methods, (field-)tables, and properties.\n\nEach *frame type* has a set layout in which values of given types are\nconcatenated along with sections of \"raw binary\" data.\n\nIn frames there are `shortstr`s, that is length-prefixed strings of\nUTF8 chars, 8 bit unsigned integers (called `octet`), unsigned 16 bit\nintegers (called `short` or `short-uint`), unsigned 32 bit integers\n(called `long` or `long-uint`), unsigned 64 bit integers (called\n`longlong` or `longlong-uint`), and flags (called `bit`).\n\nMethods are encoded as a frame giving a method ID and a sequence of\narguments of known types. The encoded method argument values are\nconcatenated (with some fun complications around \"packing\" consecutive\nbit values into bytes).\n\nAlong with the types given in frames, method arguments may be long\nbyte strings (`longstr`, not required to be UTF8) or 64 bit unsigned\nintegers to be interpreted as timestamps (yeah I don't know why\neither), or arbitrary sets of key-value pairs (called `field-table`).\n\nInside a field table the keys are `shortstr` and the values are\nprefixed with a byte tag giving the type. The types are any of the\nabove except for bits (which are replaced by byte-wide `bool`), along\nwith a NULL value `void`, a special fixed-precision number encoding\n(`decimal`), IEEE754 `float`s and `double`s, signed integers,\n`field-array` (a sequence of tagged values), and nested field-tables.\n\nRabbitMQ and QPid use a subset of the field-table types, and different\nvalue tags, established before the AMQP 0-9-1 specification was\npublished. So far as I know, no-one uses the types and tags as\npublished. http://www.rabbitmq.com/amqp-0-9-1-errata.html gives the\nlist of field-table types.\n\nLastly, there are (sets of) properties, only one of which is given in\nAMQP 0-9-1: `BasicProperties`. These are almost the same as methods,\nexcept that they appear in content header frames, which include a\ncontent size, and they carry a set of flags indicating which\nproperties are present. This scheme can save ones of bytes per message\n(messages which take a minimum of three frames each to send).\n\n*/\n\n'use strict';\n\nvar ints = require('buffer-more-ints');\n\n// JavaScript uses only doubles so what I'm testing for is whether\n// it's *better* to encode a number as a float or double. This really\n// just amounts to testing whether there's a fractional part to the\n// number, except that see below. NB I don't use bitwise operations to\n// do this 'efficiently' -- it would mask the number to 32 bits.\n//\n// At 2^50, doubles don't have sufficient precision to distinguish\n// between floating point and integer numbers (`Math.pow(2, 50) + 0.1\n// === Math.pow(2, 50)` (and, above 2^53, doubles cannot represent all\n// integers (`Math.pow(2, 53) + 1 === Math.pow(2, 53)`)). Hence\n// anything with a magnitude at or above 2^50 may as well be encoded\n// as a 64-bit integer. Except that only signed integers are supported\n// by RabbitMQ, so anything above 2^63 - 1 must be a double.\nfunction isFloatingPoint(n) {\n  return n >= 0x8000000000000000 || Math.abs(n) < 0x4000000000000 && Math.floor(n) !== n;\n}\nfunction encodeTable(buffer, val, offset) {\n  var start = offset;\n  offset += 4; // leave room for the table length\n  for (var key in val) {\n    if (val[key] !== undefined) {\n      var len = Buffer.byteLength(key);\n      buffer.writeUInt8(len, offset);\n      offset++;\n      buffer.write(key, offset, 'utf8');\n      offset += len;\n      offset += encodeFieldValue(buffer, val[key], offset);\n    }\n  }\n  var size = offset - start;\n  buffer.writeUInt32BE(size - 4, start);\n  return size;\n}\nfunction encodeArray(buffer, val, offset) {\n  var start = offset;\n  offset += 4;\n  for (var i = 0, num = val.length; i < num; i++) {\n    offset += encodeFieldValue(buffer, val[i], offset);\n  }\n  var size = offset - start;\n  buffer.writeUInt32BE(size - 4, start);\n  return size;\n}\nfunction encodeFieldValue(buffer, value, offset) {\n  var start = offset;\n  var type = typeof value,\n    val = value;\n  // A trapdoor for specifying a type, e.g., timestamp\n  if (value && type === 'object' && value.hasOwnProperty('!')) {\n    val = value.value;\n    type = value['!'];\n  }\n\n  // If it's a JS number, we'll have to guess what type to encode it\n  // as.\n  if (type == 'number') {\n    // Making assumptions about the kind of number (floating point\n    // v integer, signed, unsigned, size) desired is dangerous in\n    // general; however, in practice RabbitMQ uses only\n    // longstrings and unsigned integers in its arguments, and\n    // other clients generally conflate number types anyway. So\n    // the only distinction we care about is floating point vs\n    // integers, preferring integers since those can be promoted\n    // if necessary. If floating point is required, we may as well\n    // use double precision.\n    if (isFloatingPoint(val)) {\n      type = 'double';\n    } else {\n      // only signed values are used in tables by\n      // RabbitMQ. It *used* to (< v3.3.0) treat the byte 'b'\n      // type as unsigned, but most clients (and the spec)\n      // think it's signed, and now RabbitMQ does too.\n      if (val < 128 && val >= -128) {\n        type = 'byte';\n      } else if (val >= -0x8000 && val < 0x8000) {\n        type = 'short';\n      } else if (val >= -0x80000000 && val < 0x80000000) {\n        type = 'int';\n      } else {\n        type = 'long';\n      }\n    }\n  }\n  function tag(t) {\n    buffer.write(t, offset);\n    offset++;\n  }\n  switch (type) {\n    case 'string':\n      // no shortstr in field tables\n      var len = Buffer.byteLength(val, 'utf8');\n      tag('S');\n      buffer.writeUInt32BE(len, offset);\n      offset += 4;\n      buffer.write(val, offset, 'utf8');\n      offset += len;\n      break;\n    case 'object':\n      if (val === null) {\n        tag('V');\n      } else if (Array.isArray(val)) {\n        tag('A');\n        offset += encodeArray(buffer, val, offset);\n      } else if (Buffer.isBuffer(val)) {\n        tag('x');\n        buffer.writeUInt32BE(val.length, offset);\n        offset += 4;\n        val.copy(buffer, offset);\n        offset += val.length;\n      } else {\n        tag('F');\n        offset += encodeTable(buffer, val, offset);\n      }\n      break;\n    case 'boolean':\n      tag('t');\n      buffer.writeUInt8(val ? 1 : 0, offset);\n      offset++;\n      break;\n    // These are the types that are either guessed above, or\n    // explicitly given using the {'!': type} notation.\n    case 'double':\n    case 'float64':\n      tag('d');\n      buffer.writeDoubleBE(val, offset);\n      offset += 8;\n      break;\n    case 'byte':\n    case 'int8':\n      tag('b');\n      buffer.writeInt8(val, offset);\n      offset++;\n      break;\n    case 'short':\n    case 'int16':\n      tag('s');\n      buffer.writeInt16BE(val, offset);\n      offset += 2;\n      break;\n    case 'int':\n    case 'int32':\n      tag('I');\n      buffer.writeInt32BE(val, offset);\n      offset += 4;\n      break;\n    case 'long':\n    case 'int64':\n      tag('l');\n      ints.writeInt64BE(buffer, val, offset);\n      offset += 8;\n      break;\n\n    // Now for exotic types, those can _only_ be denoted by using\n    // `{'!': type, value: val}\n    case 'timestamp':\n      tag('T');\n      ints.writeUInt64BE(buffer, val, offset);\n      offset += 8;\n      break;\n    case 'float':\n      tag('f');\n      buffer.writeFloatBE(val, offset);\n      offset += 4;\n      break;\n    case 'decimal':\n      tag('D');\n      if (val.hasOwnProperty('places') && val.hasOwnProperty('digits') && val.places >= 0 && val.places < 256) {\n        buffer[offset] = val.places;\n        offset++;\n        buffer.writeUInt32BE(val.digits, offset);\n        offset += 4;\n      } else throw new TypeError(\"Decimal value must be {'places': 0..255, 'digits': uint32}, \" + \"got \" + JSON.stringify(val));\n      break;\n    default:\n      throw new TypeError('Unknown type to encode: ' + type);\n  }\n  return offset - start;\n}\n\n// Assume we're given a slice of the buffer that contains just the\n// fields.\nfunction decodeFields(slice) {\n  var fields = {},\n    offset = 0,\n    size = slice.length;\n  var len, key, val;\n  function decodeFieldValue() {\n    var tag = String.fromCharCode(slice[offset]);\n    offset++;\n    switch (tag) {\n      case 'b':\n        val = slice.readInt8(offset);\n        offset++;\n        break;\n      case 'S':\n        len = slice.readUInt32BE(offset);\n        offset += 4;\n        val = slice.toString('utf8', offset, offset + len);\n        offset += len;\n        break;\n      case 'I':\n        val = slice.readInt32BE(offset);\n        offset += 4;\n        break;\n      case 'D':\n        // only positive decimals, apparently.\n        var places = slice[offset];\n        offset++;\n        var digits = slice.readUInt32BE(offset);\n        offset += 4;\n        val = {\n          '!': 'decimal',\n          value: {\n            places: places,\n            digits: digits\n          }\n        };\n        break;\n      case 'T':\n        val = ints.readUInt64BE(slice, offset);\n        offset += 8;\n        val = {\n          '!': 'timestamp',\n          value: val\n        };\n        break;\n      case 'F':\n        len = slice.readUInt32BE(offset);\n        offset += 4;\n        val = decodeFields(slice.slice(offset, offset + len));\n        offset += len;\n        break;\n      case 'A':\n        len = slice.readUInt32BE(offset);\n        offset += 4;\n        decodeArray(offset + len);\n        // NB decodeArray will itself update offset and val\n        break;\n      case 'd':\n        val = slice.readDoubleBE(offset);\n        offset += 8;\n        break;\n      case 'f':\n        val = slice.readFloatBE(offset);\n        offset += 4;\n        break;\n      case 'l':\n        val = ints.readInt64BE(slice, offset);\n        offset += 8;\n        break;\n      case 's':\n        val = slice.readInt16BE(offset);\n        offset += 2;\n        break;\n      case 't':\n        val = slice[offset] != 0;\n        offset++;\n        break;\n      case 'V':\n        val = null;\n        break;\n      case 'x':\n        len = slice.readUInt32BE(offset);\n        offset += 4;\n        val = slice.slice(offset, offset + len);\n        offset += len;\n        break;\n      default:\n        throw new TypeError('Unexpected type tag \"' + tag + '\"');\n    }\n  }\n  function decodeArray(until) {\n    var vals = [];\n    while (offset < until) {\n      decodeFieldValue();\n      vals.push(val);\n    }\n    val = vals;\n  }\n  while (offset < size) {\n    len = slice.readUInt8(offset);\n    offset++;\n    key = slice.toString('utf8', offset, offset + len);\n    offset += len;\n    decodeFieldValue();\n    fields[key] = val;\n  }\n  return fields;\n}\nmodule.exports.encodeTable = encodeTable;\nmodule.exports.decodeFields = decodeFields;","map":{"version":3,"names":["ints","require","isFloatingPoint","n","Math","abs","floor","encodeTable","buffer","val","offset","start","key","undefined","len","Buffer","byteLength","writeUInt8","write","encodeFieldValue","size","writeUInt32BE","encodeArray","i","num","length","value","type","hasOwnProperty","tag","t","Array","isArray","isBuffer","copy","writeDoubleBE","writeInt8","writeInt16BE","writeInt32BE","writeInt64BE","writeUInt64BE","writeFloatBE","places","digits","TypeError","JSON","stringify","decodeFields","slice","fields","decodeFieldValue","String","fromCharCode","readInt8","readUInt32BE","toString","readInt32BE","readUInt64BE","decodeArray","readDoubleBE","readFloatBE","readInt64BE","readInt16BE","until","vals","push","readUInt8","module","exports"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/amqplib/lib/codec.js"],"sourcesContent":["//\n//\n//\n\n/*\n\nThe AMQP 0-9-1 is a mess when it comes to the types that can be\nencoded on the wire.\n\nThere are four encoding schemes, and three overlapping sets of types:\nframes, methods, (field-)tables, and properties.\n\nEach *frame type* has a set layout in which values of given types are\nconcatenated along with sections of \"raw binary\" data.\n\nIn frames there are `shortstr`s, that is length-prefixed strings of\nUTF8 chars, 8 bit unsigned integers (called `octet`), unsigned 16 bit\nintegers (called `short` or `short-uint`), unsigned 32 bit integers\n(called `long` or `long-uint`), unsigned 64 bit integers (called\n`longlong` or `longlong-uint`), and flags (called `bit`).\n\nMethods are encoded as a frame giving a method ID and a sequence of\narguments of known types. The encoded method argument values are\nconcatenated (with some fun complications around \"packing\" consecutive\nbit values into bytes).\n\nAlong with the types given in frames, method arguments may be long\nbyte strings (`longstr`, not required to be UTF8) or 64 bit unsigned\nintegers to be interpreted as timestamps (yeah I don't know why\neither), or arbitrary sets of key-value pairs (called `field-table`).\n\nInside a field table the keys are `shortstr` and the values are\nprefixed with a byte tag giving the type. The types are any of the\nabove except for bits (which are replaced by byte-wide `bool`), along\nwith a NULL value `void`, a special fixed-precision number encoding\n(`decimal`), IEEE754 `float`s and `double`s, signed integers,\n`field-array` (a sequence of tagged values), and nested field-tables.\n\nRabbitMQ and QPid use a subset of the field-table types, and different\nvalue tags, established before the AMQP 0-9-1 specification was\npublished. So far as I know, no-one uses the types and tags as\npublished. http://www.rabbitmq.com/amqp-0-9-1-errata.html gives the\nlist of field-table types.\n\nLastly, there are (sets of) properties, only one of which is given in\nAMQP 0-9-1: `BasicProperties`. These are almost the same as methods,\nexcept that they appear in content header frames, which include a\ncontent size, and they carry a set of flags indicating which\nproperties are present. This scheme can save ones of bytes per message\n(messages which take a minimum of three frames each to send).\n\n*/\n\n'use strict';\n\nvar ints = require('buffer-more-ints');\n\n// JavaScript uses only doubles so what I'm testing for is whether\n// it's *better* to encode a number as a float or double. This really\n// just amounts to testing whether there's a fractional part to the\n// number, except that see below. NB I don't use bitwise operations to\n// do this 'efficiently' -- it would mask the number to 32 bits.\n//\n// At 2^50, doubles don't have sufficient precision to distinguish\n// between floating point and integer numbers (`Math.pow(2, 50) + 0.1\n// === Math.pow(2, 50)` (and, above 2^53, doubles cannot represent all\n// integers (`Math.pow(2, 53) + 1 === Math.pow(2, 53)`)). Hence\n// anything with a magnitude at or above 2^50 may as well be encoded\n// as a 64-bit integer. Except that only signed integers are supported\n// by RabbitMQ, so anything above 2^63 - 1 must be a double.\nfunction isFloatingPoint(n) {\n    return n >= 0x8000000000000000 ||\n        (Math.abs(n) < 0x4000000000000\n         && Math.floor(n) !== n);\n}\n\nfunction encodeTable(buffer, val, offset) {\n    var start = offset;\n    offset += 4; // leave room for the table length\n    for (var key in val) {\n        if (val[key] !== undefined) {\n          var len = Buffer.byteLength(key);\n          buffer.writeUInt8(len, offset); offset++;\n          buffer.write(key, offset, 'utf8'); offset += len;\n          offset += encodeFieldValue(buffer, val[key], offset);\n        }\n    }\n    var size = offset - start;\n    buffer.writeUInt32BE(size - 4, start);\n    return size;\n}\n\nfunction encodeArray(buffer, val, offset) {\n    var start = offset;\n    offset += 4;\n    for (var i=0, num=val.length; i < num; i++) {\n        offset += encodeFieldValue(buffer, val[i], offset);\n    }\n    var size = offset - start;\n    buffer.writeUInt32BE(size - 4, start);\n    return size;\n}\n\nfunction encodeFieldValue(buffer, value, offset) {\n    var start = offset;\n    var type = typeof value, val = value;\n    // A trapdoor for specifying a type, e.g., timestamp\n    if (value && type === 'object' && value.hasOwnProperty('!')) {\n        val = value.value;\n        type = value['!'];\n    }\n\n    // If it's a JS number, we'll have to guess what type to encode it\n    // as.\n    if (type == 'number') {\n        // Making assumptions about the kind of number (floating point\n        // v integer, signed, unsigned, size) desired is dangerous in\n        // general; however, in practice RabbitMQ uses only\n        // longstrings and unsigned integers in its arguments, and\n        // other clients generally conflate number types anyway. So\n        // the only distinction we care about is floating point vs\n        // integers, preferring integers since those can be promoted\n        // if necessary. If floating point is required, we may as well\n        // use double precision.\n        if (isFloatingPoint(val)) {\n            type = 'double';\n        }\n        else { // only signed values are used in tables by\n               // RabbitMQ. It *used* to (< v3.3.0) treat the byte 'b'\n               // type as unsigned, but most clients (and the spec)\n               // think it's signed, and now RabbitMQ does too.\n            if (val < 128 && val >= -128) {\n                type = 'byte';\n            }\n            else if (val >= -0x8000 && val < 0x8000) {\n                type = 'short'\n            }\n            else if (val >= -0x80000000 && val < 0x80000000) {\n                type = 'int';\n            }\n            else {\n                type = 'long';\n            }\n        }\n    }\n\n    function tag(t) { buffer.write(t, offset); offset++; }\n\n    switch (type) {\n    case 'string': // no shortstr in field tables\n        var len = Buffer.byteLength(val, 'utf8');\n        tag('S');\n        buffer.writeUInt32BE(len, offset); offset += 4;\n        buffer.write(val, offset, 'utf8'); offset += len;\n        break;\n    case 'object':\n        if (val === null) {\n            tag('V');\n        }\n        else if (Array.isArray(val)) {\n            tag('A');\n            offset += encodeArray(buffer, val, offset);\n        }\n        else if (Buffer.isBuffer(val)) {\n            tag('x');\n            buffer.writeUInt32BE(val.length, offset); offset += 4;\n            val.copy(buffer, offset); offset += val.length;\n        }\n        else {\n            tag('F');\n            offset += encodeTable(buffer, val, offset);\n        }\n        break;\n    case 'boolean':\n        tag('t');\n        buffer.writeUInt8((val) ? 1 : 0, offset); offset++;\n        break;\n    // These are the types that are either guessed above, or\n    // explicitly given using the {'!': type} notation.\n    case 'double':\n    case 'float64':\n        tag('d');\n        buffer.writeDoubleBE(val, offset);\n        offset += 8;\n        break;\n    case 'byte':\n    case 'int8':\n        tag('b');\n        buffer.writeInt8(val, offset); offset++;\n        break;\n    case 'short':\n    case 'int16':\n        tag('s');\n        buffer.writeInt16BE(val, offset); offset += 2;\n        break;\n    case 'int':\n    case 'int32':\n        tag('I');\n        buffer.writeInt32BE(val, offset); offset += 4;\n        break;\n    case 'long':\n    case 'int64':\n        tag('l');\n        ints.writeInt64BE(buffer, val, offset); offset += 8;\n        break;\n\n    // Now for exotic types, those can _only_ be denoted by using\n    // `{'!': type, value: val}\n    case 'timestamp':\n        tag('T');\n        ints.writeUInt64BE(buffer, val, offset); offset += 8;\n        break;\n    case 'float':\n        tag('f');\n        buffer.writeFloatBE(val, offset); offset += 4;\n        break;\n    case 'decimal':\n        tag('D');\n        if (val.hasOwnProperty('places') && val.hasOwnProperty('digits')\n            && val.places >= 0 && val.places < 256) {\n            buffer[offset] = val.places; offset++;\n            buffer.writeUInt32BE(val.digits, offset); offset += 4;\n        }\n        else throw new TypeError(\n            \"Decimal value must be {'places': 0..255, 'digits': uint32}, \" +\n                \"got \" + JSON.stringify(val));\n        break;\n    default:\n        throw new TypeError('Unknown type to encode: ' + type);\n    }\n    return offset - start;\n}\n\n// Assume we're given a slice of the buffer that contains just the\n// fields.\nfunction decodeFields(slice) {\n    var fields = {}, offset = 0, size = slice.length;\n    var len, key, val;\n\n    function decodeFieldValue() {\n        var tag = String.fromCharCode(slice[offset]); offset++;\n        switch (tag) {\n        case 'b':\n            val = slice.readInt8(offset); offset++;\n            break;\n        case 'S':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = slice.toString('utf8', offset, offset + len);\n            offset += len;\n            break;\n        case 'I':\n            val = slice.readInt32BE(offset); offset += 4;\n            break;\n        case 'D': // only positive decimals, apparently.\n            var places = slice[offset]; offset++;\n            var digits = slice.readUInt32BE(offset); offset += 4;\n            val = {'!': 'decimal', value: {places: places, digits: digits}};\n            break;\n        case 'T':\n            val = ints.readUInt64BE(slice, offset); offset += 8;\n            val = {'!': 'timestamp', value: val};\n            break;\n        case 'F':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = decodeFields(slice.slice(offset, offset + len));\n            offset += len;\n            break;\n        case 'A':\n            len = slice.readUInt32BE(offset); offset += 4;\n            decodeArray(offset + len);\n            // NB decodeArray will itself update offset and val\n            break;\n        case 'd':\n            val = slice.readDoubleBE(offset); offset += 8;\n            break;\n        case 'f':\n            val = slice.readFloatBE(offset); offset += 4;\n            break;\n        case 'l':\n            val = ints.readInt64BE(slice, offset); offset += 8;\n            break;\n        case 's':\n            val = slice.readInt16BE(offset); offset += 2;\n            break;\n        case 't':\n            val = slice[offset] != 0; offset++;\n            break;\n        case 'V':\n            val = null;\n            break;\n        case 'x':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = slice.slice(offset, offset + len);\n            offset += len;\n            break;\n        default:\n            throw new TypeError('Unexpected type tag \"' + tag +'\"');\n        }\n    }\n\n    function decodeArray(until) {\n        var vals = [];\n        while (offset < until) {\n            decodeFieldValue();\n            vals.push(val);\n        }\n        val = vals;\n    }\n\n    while (offset < size) {\n        len = slice.readUInt8(offset); offset++;\n        key = slice.toString('utf8', offset, offset + len);\n        offset += len;\n        decodeFieldValue();\n        fields[key] = val;\n    }\n    return fields;\n}\n\nmodule.exports.encodeTable = encodeTable;\nmodule.exports.decodeFields = decodeFields;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}