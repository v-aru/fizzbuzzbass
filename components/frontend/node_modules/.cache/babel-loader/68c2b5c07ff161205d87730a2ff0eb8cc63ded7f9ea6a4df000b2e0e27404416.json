{"ast":null,"code":"/*!\n * RSA library for Node.js\n *\n * Copyright (c) 2014 rzcoder\n * All Rights Reserved.\n *\n * License BSD\n */\n\nvar constants = require('constants');\nvar rsa = require('./libs/rsa.js');\nvar crypt = require('crypto');\nvar ber = require('asn1').Ber;\nvar _ = require('./utils')._;\nvar utils = require('./utils');\nvar schemes = require('./schemes/schemes.js');\nvar formats = require('./formats/formats.js');\nif (typeof constants.RSA_NO_PADDING == \"undefined\") {\n  //patch for node v0.10.x, constants do not defined\n  constants.RSA_NO_PADDING = 3;\n}\nmodule.exports = function () {\n  var SUPPORTED_HASH_ALGORITHMS = {\n    node10: ['md4', 'md5', 'ripemd160', 'sha', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    node: ['md4', 'md5', 'ripemd160', 'sha', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    iojs: ['md4', 'md5', 'ripemd160', 'sha', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\n  };\n  var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\n  var DEFAULT_SIGNING_SCHEME = 'pkcs1';\n  var DEFAULT_EXPORT_FORMAT = 'private';\n  var EXPORT_FORMAT_ALIASES = {\n    'private': 'pkcs1-private-pem',\n    'private-der': 'pkcs1-private-der',\n    'public': 'pkcs8-public-pem',\n    'public-der': 'pkcs8-public-der'\n  };\n\n  /**\n   * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\n   * @constructor\n   */\n  function NodeRSA(key, format, options) {\n    if (!(this instanceof NodeRSA)) {\n      return new NodeRSA(key, format, options);\n    }\n    if (_.isObject(format)) {\n      options = format;\n      format = undefined;\n    }\n    this.$options = {\n      signingScheme: DEFAULT_SIGNING_SCHEME,\n      signingSchemeOptions: {\n        hash: 'sha256',\n        saltLength: null\n      },\n      encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\n      encryptionSchemeOptions: {\n        hash: 'sha1',\n        label: null\n      },\n      environment: utils.detectEnvironment(),\n      rsaUtils: this\n    };\n    this.keyPair = new rsa.Key();\n    this.$cache = {};\n    if (Buffer.isBuffer(key) || _.isString(key)) {\n      this.importKey(key, format);\n    } else if (_.isObject(key)) {\n      this.generateKeyPair(key.b, key.e);\n    }\n    this.setOptions(options);\n  }\n\n  /**\n   * Set and validate options for key instance\n   * @param options\n   */\n  NodeRSA.prototype.setOptions = function (options) {\n    options = options || {};\n    if (options.environment) {\n      this.$options.environment = options.environment;\n    }\n    if (options.signingScheme) {\n      if (_.isString(options.signingScheme)) {\n        var signingScheme = options.signingScheme.toLowerCase().split('-');\n        if (signingScheme.length == 1) {\n          if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\n            this.$options.signingSchemeOptions = {\n              hash: signingScheme[0]\n            };\n            this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\n          } else {\n            this.$options.signingScheme = signingScheme[0];\n            this.$options.signingSchemeOptions = {\n              hash: null\n            };\n          }\n        } else {\n          this.$options.signingSchemeOptions = {\n            hash: signingScheme[1]\n          };\n          this.$options.signingScheme = signingScheme[0];\n        }\n      } else if (_.isObject(options.signingScheme)) {\n        this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\n        this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\n      }\n      if (!schemes.isSignature(this.$options.signingScheme)) {\n        throw Error('Unsupported signing scheme');\n      }\n      if (this.$options.signingSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\n        throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n      }\n    }\n    if (options.encryptionScheme) {\n      if (_.isString(options.encryptionScheme)) {\n        this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\n        this.$options.encryptionSchemeOptions = {};\n      } else if (_.isObject(options.encryptionScheme)) {\n        this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\n        this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\n      }\n      if (!schemes.isEncryption(this.$options.encryptionScheme)) {\n        throw Error('Unsupported encryption scheme');\n      }\n      if (this.$options.encryptionSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\n        throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n      }\n    }\n    this.keyPair.setOptions(this.$options);\n  };\n\n  /**\n   * Generate private/public keys pair\n   *\n   * @param bits {int} length key in bits. Default 2048.\n   * @param exp {int} public exponent. Default 65537.\n   * @returns {NodeRSA}\n   */\n  NodeRSA.prototype.generateKeyPair = function (bits, exp) {\n    bits = bits || 2048;\n    exp = exp || 65537;\n    if (bits % 8 !== 0) {\n      throw Error('Key size must be a multiple of 8.');\n    }\n    this.keyPair.generate(bits, exp.toString(16));\n    this.$cache = {};\n    return this;\n  };\n\n  /**\n   * Importing key\n   * @param keyData {string|buffer|Object}\n   * @param format {string}\n   */\n  NodeRSA.prototype.importKey = function (keyData, format) {\n    if (!keyData) {\n      throw Error(\"Empty key given\");\n    }\n    if (format) {\n      format = EXPORT_FORMAT_ALIASES[format] || format;\n    }\n    if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\n      throw Error(\"Key format must be specified\");\n    }\n    this.$cache = {};\n  };\n\n  /**\n   * Exporting key\n   * @param [format] {string}\n   */\n  NodeRSA.prototype.exportKey = function (format) {\n    format = format || DEFAULT_EXPORT_FORMAT;\n    format = EXPORT_FORMAT_ALIASES[format] || format;\n    if (!this.$cache[format]) {\n      this.$cache[format] = formats.detectAndExport(this.keyPair, format);\n    }\n    return this.$cache[format];\n  };\n\n  /**\n   * Check if key pair contains private key\n   */\n  NodeRSA.prototype.isPrivate = function () {\n    return this.keyPair.isPrivate();\n  };\n\n  /**\n   * Check if key pair contains public key\n   * @param [strict] {boolean} - public key only, return false if have private exponent\n   */\n  NodeRSA.prototype.isPublic = function (strict) {\n    return this.keyPair.isPublic(strict);\n  };\n\n  /**\n   * Check if key pair doesn't contains any data\n   */\n  NodeRSA.prototype.isEmpty = function (strict) {\n    return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\n  };\n\n  /**\n   * Encrypting data method with public key\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {string|Buffer}\n   */\n  NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\n    return this.$$encryptKey(false, buffer, encoding, source_encoding);\n  };\n\n  /**\n   * Decrypting data method with private key\n   *\n   * @param buffer {Buffer} - buffer for decrypting\n   * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\n   * @returns {Buffer|object|string}\n   */\n  NodeRSA.prototype.decrypt = function (buffer, encoding) {\n    return this.$$decryptKey(false, buffer, encoding);\n  };\n\n  /**\n   * Encrypting data method with private key\n   *\n   * Parameters same as `encrypt` method\n   */\n  NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\n    return this.$$encryptKey(true, buffer, encoding, source_encoding);\n  };\n\n  /**\n   * Decrypting data method with public key\n   *\n   * Parameters same as `decrypt` method\n   */\n  NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\n    return this.$$decryptKey(true, buffer, encoding);\n  };\n\n  /**\n   * Encrypting data method with custom key\n   */\n  NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\n    try {\n      var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\n      if (encoding == 'buffer' || !encoding) {\n        return res;\n      } else {\n        return res.toString(encoding);\n      }\n    } catch (e) {\n      throw Error('Error during encryption. Original error: ' + e);\n    }\n  };\n\n  /**\n   * Decrypting data method with custom key\n   */\n  NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\n    try {\n      buffer = _.isString(buffer) ? new Buffer(buffer, 'base64') : buffer;\n      var res = this.keyPair.decrypt(buffer, usePublic);\n      if (res === null) {\n        throw Error('Key decrypt method returns null.');\n      }\n      return this.$getDecryptedData(res, encoding);\n    } catch (e) {\n      throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\n    }\n  };\n\n  /**\n   *  Signing data\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {string|Buffer}\n   */\n  NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\n    if (!this.isPrivate()) {\n      throw Error(\"This is not private key\");\n    }\n    var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\n    if (encoding && encoding != 'buffer') {\n      res = res.toString(encoding);\n    }\n    return res;\n  };\n\n  /**\n   *  Verifying signed data\n   *\n   * @param buffer - signed data\n   * @param signature\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @returns {*}\n   */\n  NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\n    if (!this.isPublic()) {\n      throw Error(\"This is not public key\");\n    }\n    signature_encoding = !signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding;\n    return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\n  };\n\n  /**\n   * Returns key size in bits\n   * @returns {int}\n   */\n  NodeRSA.prototype.getKeySize = function () {\n    return this.keyPair.keySize;\n  };\n\n  /**\n   * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\n   * @returns {int}\n   */\n  NodeRSA.prototype.getMaxMessageSize = function () {\n    return this.keyPair.maxMessageLength;\n  };\n\n  /**\n   * Preparing given data for encrypting/signing. Just make new/return Buffer object.\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {Buffer}\n   */\n  NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\n    if (_.isString(buffer) || _.isNumber(buffer)) {\n      return new Buffer('' + buffer, encoding || 'utf8');\n    } else if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    } else if (_.isObject(buffer)) {\n      return new Buffer(JSON.stringify(buffer));\n    } else {\n      throw Error(\"Unexpected data type\");\n    }\n  };\n\n  /**\n   *\n   * @param buffer {Buffer} - decrypted data.\n   * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\n   * @returns {*}\n   */\n  NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\n    encoding = encoding || 'buffer';\n    if (encoding == 'buffer') {\n      return buffer;\n    } else if (encoding == 'json') {\n      return JSON.parse(buffer.toString());\n    } else {\n      return buffer.toString(encoding);\n    }\n  };\n  return NodeRSA;\n}();","map":{"version":3,"names":["constants","require","rsa","crypt","ber","Ber","_","utils","schemes","formats","RSA_NO_PADDING","module","exports","SUPPORTED_HASH_ALGORITHMS","node10","node","iojs","browser","DEFAULT_ENCRYPTION_SCHEME","DEFAULT_SIGNING_SCHEME","DEFAULT_EXPORT_FORMAT","EXPORT_FORMAT_ALIASES","NodeRSA","key","format","options","isObject","undefined","$options","signingScheme","signingSchemeOptions","hash","saltLength","encryptionScheme","encryptionSchemeOptions","label","environment","detectEnvironment","rsaUtils","keyPair","Key","$cache","Buffer","isBuffer","isString","importKey","generateKeyPair","b","e","setOptions","prototype","toLowerCase","split","length","indexOf","scheme","omit","isSignature","Error","isEncryption","bits","exp","generate","toString","keyData","detectAndImport","exportKey","detectAndExport","isPrivate","isPublic","strict","isEmpty","n","d","encrypt","buffer","encoding","source_encoding","$$encryptKey","decrypt","$$decryptKey","encryptPrivate","decryptPublic","usePrivate","res","$getDataForEncrypt","usePublic","$getDecryptedData","sign","verify","signature","signature_encoding","getKeySize","keySize","getMaxMessageSize","maxMessageLength","isNumber","JSON","stringify","parse"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/node-rsa/src/NodeRSA.js"],"sourcesContent":["/*!\n * RSA library for Node.js\n *\n * Copyright (c) 2014 rzcoder\n * All Rights Reserved.\n *\n * License BSD\n */\n\nvar constants = require('constants');\nvar rsa = require('./libs/rsa.js');\nvar crypt = require('crypto');\nvar ber = require('asn1').Ber;\nvar _ = require('./utils')._;\nvar utils = require('./utils');\nvar schemes = require('./schemes/schemes.js');\nvar formats = require('./formats/formats.js');\n\nif (typeof constants.RSA_NO_PADDING == \"undefined\") {\n    //patch for node v0.10.x, constants do not defined\n    constants.RSA_NO_PADDING = 3;\n}\n\nmodule.exports = (function () {\n    var SUPPORTED_HASH_ALGORITHMS = {\n        node10: ['md4', 'md5', 'ripemd160', 'sha', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        node: ['md4', 'md5', 'ripemd160', 'sha', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        iojs: ['md4', 'md5', 'ripemd160', 'sha', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\n    };\n\n    var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\n    var DEFAULT_SIGNING_SCHEME = 'pkcs1';\n\n    var DEFAULT_EXPORT_FORMAT = 'private';\n    var EXPORT_FORMAT_ALIASES = {\n        'private': 'pkcs1-private-pem',\n        'private-der': 'pkcs1-private-der',\n        'public': 'pkcs8-public-pem',\n        'public-der': 'pkcs8-public-der',\n    };\n\n    /**\n     * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\n     * @constructor\n     */\n    function NodeRSA(key, format, options) {\n        if (!(this instanceof NodeRSA)) {\n            return new NodeRSA(key, format, options);\n        }\n\n        if (_.isObject(format)) {\n            options = format;\n            format = undefined;\n        }\n\n        this.$options = {\n            signingScheme: DEFAULT_SIGNING_SCHEME,\n            signingSchemeOptions: {\n                hash: 'sha256',\n                saltLength: null\n            },\n            encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\n            encryptionSchemeOptions: {\n                hash: 'sha1',\n                label: null\n            },\n            environment: utils.detectEnvironment(),\n            rsaUtils: this\n        };\n        this.keyPair = new rsa.Key();\n        this.$cache = {};\n\n        if (Buffer.isBuffer(key) || _.isString(key)) {\n            this.importKey(key, format);\n        } else if (_.isObject(key)) {\n            this.generateKeyPair(key.b, key.e);\n        }\n\n        this.setOptions(options);\n    }\n\n    /**\n     * Set and validate options for key instance\n     * @param options\n     */\n    NodeRSA.prototype.setOptions = function (options) {\n        options = options || {};\n        if (options.environment) {\n            this.$options.environment = options.environment;\n        }\n\n        if (options.signingScheme) {\n            if (_.isString(options.signingScheme)) {\n                var signingScheme = options.signingScheme.toLowerCase().split('-');\n                if (signingScheme.length == 1) {\n                    if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\n                        this.$options.signingSchemeOptions = {\n                            hash: signingScheme[0]\n                        };\n                        this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\n                    } else {\n                        this.$options.signingScheme = signingScheme[0];\n                        this.$options.signingSchemeOptions = {\n                            hash: null\n                        };\n                    }\n                } else {\n                    this.$options.signingSchemeOptions = {\n                        hash: signingScheme[1]\n                    };\n                    this.$options.signingScheme = signingScheme[0];\n                }\n            } else if (_.isObject(options.signingScheme)) {\n                this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\n                this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\n            }\n\n            if (!schemes.isSignature(this.$options.signingScheme)) {\n                throw Error('Unsupported signing scheme');\n            }\n\n            if (this.$options.signingSchemeOptions.hash &&\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n            }\n        }\n\n        if (options.encryptionScheme) {\n            if (_.isString(options.encryptionScheme)) {\n                this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\n                this.$options.encryptionSchemeOptions = {};\n            } else if (_.isObject(options.encryptionScheme)) {\n                this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\n                this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\n            }\n\n            if (!schemes.isEncryption(this.$options.encryptionScheme)) {\n                throw Error('Unsupported encryption scheme');\n            }\n\n            if (this.$options.encryptionSchemeOptions.hash &&\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n            }\n        }\n\n        this.keyPair.setOptions(this.$options);\n    };\n\n    /**\n     * Generate private/public keys pair\n     *\n     * @param bits {int} length key in bits. Default 2048.\n     * @param exp {int} public exponent. Default 65537.\n     * @returns {NodeRSA}\n     */\n    NodeRSA.prototype.generateKeyPair = function (bits, exp) {\n        bits = bits || 2048;\n        exp = exp || 65537;\n\n        if (bits % 8 !== 0) {\n            throw Error('Key size must be a multiple of 8.');\n        }\n\n        this.keyPair.generate(bits, exp.toString(16));\n        this.$cache = {};\n        return this;\n    };\n\n    /**\n     * Importing key\n     * @param keyData {string|buffer|Object}\n     * @param format {string}\n     */\n    NodeRSA.prototype.importKey = function (keyData, format) {\n        if (!keyData) {\n            throw Error(\"Empty key given\");\n        }\n\n        if (format) {\n            format = EXPORT_FORMAT_ALIASES[format] || format;\n        }\n\n        if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\n            throw Error(\"Key format must be specified\");\n        }\n\n        this.$cache = {};\n    };\n\n    /**\n     * Exporting key\n     * @param [format] {string}\n     */\n    NodeRSA.prototype.exportKey = function (format) {\n        format = format || DEFAULT_EXPORT_FORMAT;\n        format = EXPORT_FORMAT_ALIASES[format] || format;\n\n        if (!this.$cache[format]) {\n            this.$cache[format] = formats.detectAndExport(this.keyPair, format);\n        }\n\n        return this.$cache[format];\n    };\n\n    /**\n     * Check if key pair contains private key\n     */\n    NodeRSA.prototype.isPrivate = function () {\n        return this.keyPair.isPrivate();\n    };\n\n    /**\n     * Check if key pair contains public key\n     * @param [strict] {boolean} - public key only, return false if have private exponent\n     */\n    NodeRSA.prototype.isPublic = function (strict) {\n        return this.keyPair.isPublic(strict);\n    };\n\n    /**\n     * Check if key pair doesn't contains any data\n     */\n    NodeRSA.prototype.isEmpty = function (strict) {\n        return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\n    };\n\n    /**\n     * Encrypting data method with public key\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {string|Buffer}\n     */\n    NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\n        return this.$$encryptKey(false, buffer, encoding, source_encoding);\n    };\n\n    /**\n     * Decrypting data method with private key\n     *\n     * @param buffer {Buffer} - buffer for decrypting\n     * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\n     * @returns {Buffer|object|string}\n     */\n    NodeRSA.prototype.decrypt = function (buffer, encoding) {\n        return this.$$decryptKey(false, buffer, encoding);\n    };\n\n    /**\n     * Encrypting data method with private key\n     *\n     * Parameters same as `encrypt` method\n     */\n    NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\n        return this.$$encryptKey(true, buffer, encoding, source_encoding);\n    };\n\n    /**\n     * Decrypting data method with public key\n     *\n     * Parameters same as `decrypt` method\n     */\n    NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\n        return this.$$decryptKey(true, buffer, encoding);\n    };\n\n    /**\n     * Encrypting data method with custom key\n     */\n    NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\n        try {\n            var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\n\n            if (encoding == 'buffer' || !encoding) {\n                return res;\n            } else {\n                return res.toString(encoding);\n            }\n        } catch (e) {\n            throw Error('Error during encryption. Original error: ' + e);\n        }\n    };\n\n    /**\n     * Decrypting data method with custom key\n     */\n    NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\n        try {\n            buffer = _.isString(buffer) ? new Buffer(buffer, 'base64') : buffer;\n            var res = this.keyPair.decrypt(buffer, usePublic);\n\n            if (res === null) {\n                throw Error('Key decrypt method returns null.');\n            }\n\n            return this.$getDecryptedData(res, encoding);\n        } catch (e) {\n            throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\n        }\n    };\n\n    /**\n     *  Signing data\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {string|Buffer}\n     */\n    NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\n        if (!this.isPrivate()) {\n            throw Error(\"This is not private key\");\n        }\n\n        var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\n\n        if (encoding && encoding != 'buffer') {\n            res = res.toString(encoding);\n        }\n\n        return res;\n    };\n\n    /**\n     *  Verifying signed data\n     *\n     * @param buffer - signed data\n     * @param signature\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @returns {*}\n     */\n    NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\n        if (!this.isPublic()) {\n            throw Error(\"This is not public key\");\n        }\n        signature_encoding = (!signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding);\n        return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\n    };\n\n    /**\n     * Returns key size in bits\n     * @returns {int}\n     */\n    NodeRSA.prototype.getKeySize = function () {\n        return this.keyPair.keySize;\n    };\n\n    /**\n     * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\n     * @returns {int}\n     */\n    NodeRSA.prototype.getMaxMessageSize = function () {\n        return this.keyPair.maxMessageLength;\n    };\n\n    /**\n     * Preparing given data for encrypting/signing. Just make new/return Buffer object.\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {Buffer}\n     */\n    NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\n        if (_.isString(buffer) || _.isNumber(buffer)) {\n            return new Buffer('' + buffer, encoding || 'utf8');\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (_.isObject(buffer)) {\n            return new Buffer(JSON.stringify(buffer));\n        } else {\n            throw Error(\"Unexpected data type\");\n        }\n    };\n\n    /**\n     *\n     * @param buffer {Buffer} - decrypted data.\n     * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\n     * @returns {*}\n     */\n    NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\n        encoding = encoding || 'buffer';\n\n        if (encoding == 'buffer') {\n            return buffer;\n        } else if (encoding == 'json') {\n            return JSON.parse(buffer.toString());\n        } else {\n            return buffer.toString(encoding);\n        }\n    };\n\n    return NodeRSA;\n})();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}