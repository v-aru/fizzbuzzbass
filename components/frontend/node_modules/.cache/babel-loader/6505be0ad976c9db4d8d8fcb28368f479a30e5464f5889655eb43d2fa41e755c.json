{"ast":null,"code":"'use strict';\n\nvar assert = require(\"assert\");\n\n// JavaScript is numerically challenged\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// The maximum contiguous integer that can be held in a IEEE754 double\nvar MAX_INT = 0x1fffffffffffff;\nfunction isContiguousInt(val) {\n  return val <= MAX_INT && val >= -MAX_INT;\n}\nfunction assertContiguousInt(val) {\n  assert(isContiguousInt(val), \"number cannot be represented as a contiguous integer\");\n}\nmodule.exports.isContiguousInt = isContiguousInt;\nmodule.exports.assertContiguousInt = assertContiguousInt;\n\n// Fill in the regular procedures\n['UInt', 'Int'].forEach(function (sign) {\n  var suffix = sign + '8';\n  module.exports['read' + suffix] = Buffer.prototype['read' + suffix].call;\n  module.exports['write' + suffix] = Buffer.prototype['write' + suffix].call;\n  ['16', '32'].forEach(function (size) {\n    ['LE', 'BE'].forEach(function (endian) {\n      var suffix = sign + size + endian;\n      var read = Buffer.prototype['read' + suffix];\n      module.exports['read' + suffix] = function (buf, offset, noAssert) {\n        return read.call(buf, offset, noAssert);\n      };\n      var write = Buffer.prototype['write' + suffix];\n      module.exports['write' + suffix] = function (buf, val, offset, noAssert) {\n        return write.call(buf, val, offset, noAssert);\n      };\n    });\n  });\n});\n\n// Check that a value is an integer within the given range\nfunction check_int(val, min, max) {\n  assert.ok(typeof val == 'number' && val >= min && val <= max && Math.floor(val) === val, \"not a number in the required range\");\n}\nfunction readUInt24BE(buf, offset, noAssert) {\n  return buf.readUInt8(offset, noAssert) << 16 | buf.readUInt16BE(offset + 1, noAssert);\n}\nmodule.exports.readUInt24BE = readUInt24BE;\nfunction writeUInt24BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffff);\n    assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeUInt8(val >>> 16, offset, noAssert);\n  buf.writeUInt16BE(val & 0xffff, offset + 1, noAssert);\n}\nmodule.exports.writeUInt24BE = writeUInt24BE;\nfunction readUInt40BE(buf, offset, noAssert) {\n  return (buf.readUInt8(offset, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1, noAssert);\n}\nmodule.exports.readUInt40BE = readUInt40BE;\nfunction writeUInt40BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffff);\n    assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n  buf.writeInt32BE(val & -1, offset + 1, noAssert);\n}\nmodule.exports.writeUInt40BE = writeUInt40BE;\nfunction readUInt48BE(buf, offset, noAssert) {\n  return buf.readUInt16BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2, noAssert);\n}\nmodule.exports.readUInt48BE = readUInt48BE;\nfunction writeUInt48BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffffff);\n    assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n  buf.writeInt32BE(val & -1, offset + 2, noAssert);\n}\nmodule.exports.writeUInt48BE = writeUInt48BE;\nfunction readUInt56BE(buf, offset, noAssert) {\n  return ((buf.readUInt8(offset, noAssert) || 0) << 16 | buf.readUInt16BE(offset + 1, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3, noAssert);\n}\nmodule.exports.readUInt56BE = readUInt56BE;\nfunction writeUInt56BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffffffff);\n    assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x100000000000000) {\n    var hi = Math.floor(val * SHIFT_RIGHT_32);\n    buf.writeUInt8(hi >>> 16, offset, noAssert);\n    buf.writeUInt16BE(hi & 0xffff, offset + 1, noAssert);\n    buf.writeInt32BE(val & -1, offset + 3, noAssert);\n  } else {\n    // Special case because 2^56-1 gets rounded up to 2^56\n    buf[offset] = 0xff;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n  }\n}\nmodule.exports.writeUInt56BE = writeUInt56BE;\nfunction readUInt64BE(buf, offset, noAssert) {\n  return buf.readUInt32BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4, noAssert);\n}\nmodule.exports.readUInt64BE = readUInt64BE;\nfunction writeUInt64BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffffffffff);\n    assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x10000000000000000) {\n    buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 4, noAssert);\n  } else {\n    // Special case because 2^64-1 gets rounded up to 2^64\n    buf[offset] = 0xff;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n    buf[offset + 7] = 0xff;\n  }\n}\nmodule.exports.writeUInt64BE = writeUInt64BE;\nfunction readUInt24LE(buf, offset, noAssert) {\n  return buf.readUInt8(offset + 2, noAssert) << 16 | buf.readUInt16LE(offset, noAssert);\n}\nmodule.exports.readUInt24LE = readUInt24LE;\nfunction writeUInt24LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffff);\n    assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeUInt16LE(val & 0xffff, offset, noAssert);\n  buf.writeUInt8(val >>> 16, offset + 2, noAssert);\n}\nmodule.exports.writeUInt24LE = writeUInt24LE;\nfunction readUInt40LE(buf, offset, noAssert) {\n  return (buf.readUInt8(offset + 4, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt40LE = readUInt40LE;\nfunction writeUInt40LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffff);\n    assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt32LE(val & -1, offset, noAssert);\n  buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeUInt40LE = writeUInt40LE;\nfunction readUInt48LE(buf, offset, noAssert) {\n  return buf.readUInt16LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt48LE = readUInt48LE;\nfunction writeUInt48LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffffff);\n    assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt32LE(val & -1, offset, noAssert);\n  buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeUInt48LE = writeUInt48LE;\nfunction readUInt56LE(buf, offset, noAssert) {\n  return ((buf.readUInt8(offset + 6, noAssert) || 0) << 16 | buf.readUInt16LE(offset + 4, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt56LE = readUInt56LE;\nfunction writeUInt56LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffffffff);\n    assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x100000000000000) {\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    var hi = Math.floor(val * SHIFT_RIGHT_32);\n    buf.writeUInt16LE(hi & 0xffff, offset + 4, noAssert);\n    buf.writeUInt8(hi >>> 16, offset + 6, noAssert);\n  } else {\n    // Special case because 2^56-1 gets rounded up to 2^56\n    buf[offset] = 0xff;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n  }\n}\nmodule.exports.writeUInt56LE = writeUInt56LE;\nfunction readUInt64LE(buf, offset, noAssert) {\n  return buf.readUInt32LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, 0, 0xffffffffffffffff);\n    assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x10000000000000000) {\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n  } else {\n    // Special case because 2^64-1 gets rounded up to 2^64\n    buf[offset] = 0xff;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n    buf[offset + 7] = 0xff;\n  }\n}\nmodule.exports.writeUInt64LE = writeUInt64LE;\nfunction readInt24BE(buf, offset, noAssert) {\n  return (buf.readInt8(offset, noAssert) << 16) + buf.readUInt16BE(offset + 1, noAssert);\n}\nmodule.exports.readInt24BE = readInt24BE;\nfunction writeInt24BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x800000, 0x7fffff);\n    assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt8(val >> 16, offset, noAssert);\n  buf.writeUInt16BE(val & 0xffff, offset + 1, noAssert);\n}\nmodule.exports.writeInt24BE = writeInt24BE;\nfunction readInt40BE(buf, offset, noAssert) {\n  return (buf.readInt8(offset, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1, noAssert);\n}\nmodule.exports.readInt40BE = readInt40BE;\nfunction writeInt40BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x8000000000, 0x7fffffffff);\n    assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n  buf.writeInt32BE(val & -1, offset + 1, noAssert);\n}\nmodule.exports.writeInt40BE = writeInt40BE;\nfunction readInt48BE(buf, offset, noAssert) {\n  return buf.readInt16BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2, noAssert);\n}\nmodule.exports.readInt48BE = readInt48BE;\nfunction writeInt48BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x800000000000, 0x7fffffffffff);\n    assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n  buf.writeInt32BE(val & -1, offset + 2, noAssert);\n}\nmodule.exports.writeInt48BE = writeInt48BE;\nfunction readInt56BE(buf, offset, noAssert) {\n  return (((buf.readInt8(offset, noAssert) || 0) << 16) + buf.readUInt16BE(offset + 1, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3, noAssert);\n}\nmodule.exports.readInt56BE = readInt56BE;\nfunction writeInt56BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x800000000000000, 0x7fffffffffffff);\n    assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x80000000000000) {\n    var hi = Math.floor(val * SHIFT_RIGHT_32);\n    buf.writeInt8(hi >> 16, offset, noAssert);\n    buf.writeUInt16BE(hi & 0xffff, offset + 1, noAssert);\n    buf.writeInt32BE(val & -1, offset + 3, noAssert);\n  } else {\n    // Special case because 2^55-1 gets rounded up to 2^55\n    buf[offset] = 0x7f;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n  }\n}\nmodule.exports.writeInt56BE = writeInt56BE;\nfunction readInt64BE(buf, offset, noAssert) {\n  return buf.readInt32BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4, noAssert);\n}\nmodule.exports.readInt64BE = readInt64BE;\nfunction writeInt64BE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x800000000000000000, 0x7fffffffffffffff);\n    assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x8000000000000000) {\n    buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 4, noAssert);\n  } else {\n    // Special case because 2^63-1 gets rounded up to 2^63\n    buf[offset] = 0x7f;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n    buf[offset + 7] = 0xff;\n  }\n}\nmodule.exports.writeInt64BE = writeInt64BE;\nfunction readInt24LE(buf, offset, noAssert) {\n  return (buf.readInt8(offset + 2, noAssert) << 16) + buf.readUInt16LE(offset, noAssert);\n}\nmodule.exports.readInt24LE = readInt24LE;\nfunction writeInt24LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x800000, 0x7fffff);\n    assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeUInt16LE(val & 0xffff, offset, noAssert);\n  buf.writeInt8(val >> 16, offset + 2, noAssert);\n}\nmodule.exports.writeInt24LE = writeInt24LE;\nfunction readInt40LE(buf, offset, noAssert) {\n  return (buf.readInt8(offset + 4, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt40LE = readInt40LE;\nfunction writeInt40LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x8000000000, 0x7fffffffff);\n    assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt32LE(val & -1, offset, noAssert);\n  buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeInt40LE = writeInt40LE;\nfunction readInt48LE(buf, offset, noAssert) {\n  return buf.readInt16LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt48LE = readInt48LE;\nfunction writeInt48LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x800000000000, 0x7fffffffffff);\n    assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  buf.writeInt32LE(val & -1, offset, noAssert);\n  buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeInt48LE = writeInt48LE;\nfunction readInt56LE(buf, offset, noAssert) {\n  return (((buf.readInt8(offset + 6, noAssert) || 0) << 16) + buf.readUInt16LE(offset + 4, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt56LE = readInt56LE;\nfunction writeInt56LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x80000000000000, 0x7fffffffffffff);\n    assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x80000000000000) {\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    var hi = Math.floor(val * SHIFT_RIGHT_32);\n    buf.writeUInt16LE(hi & 0xffff, offset + 4, noAssert);\n    buf.writeInt8(hi >> 16, offset + 6, noAssert);\n  } else {\n    // Special case because 2^55-1 gets rounded up to 2^55\n    buf[offset] = 0xff;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0x7f;\n  }\n}\nmodule.exports.writeInt56LE = writeInt56LE;\nfunction readInt64LE(buf, offset, noAssert) {\n  return buf.readInt32LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt64LE = readInt64LE;\nfunction writeInt64LE(buf, val, offset, noAssert) {\n  if (!noAssert) {\n    check_int(val, -0x8000000000000000, 0x7fffffffffffffff);\n    assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n  }\n  if (val < 0x8000000000000000) {\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n  } else {\n    // Special case because 2^55-1 gets rounded up to 2^55\n    buf[offset] = 0xff;\n    buf[offset + 1] = 0xff;\n    buf[offset + 2] = 0xff;\n    buf[offset + 3] = 0xff;\n    buf[offset + 4] = 0xff;\n    buf[offset + 5] = 0xff;\n    buf[offset + 6] = 0xff;\n    buf[offset + 7] = 0x7f;\n  }\n}\nmodule.exports.writeInt64LE = writeInt64LE;","map":{"version":3,"names":["assert","require","SHIFT_LEFT_32","SHIFT_RIGHT_32","MAX_INT","isContiguousInt","val","assertContiguousInt","module","exports","forEach","sign","suffix","Buffer","prototype","call","size","endian","read","buf","offset","noAssert","write","check_int","min","max","ok","Math","floor","readUInt24BE","readUInt8","readUInt16BE","writeUInt24BE","length","writeUInt8","writeUInt16BE","readUInt40BE","readUInt32BE","writeUInt40BE","writeInt32BE","readUInt48BE","writeUInt48BE","readUInt56BE","writeUInt56BE","hi","readUInt64BE","writeUInt64BE","writeUInt32BE","readUInt24LE","readUInt16LE","writeUInt24LE","writeUInt16LE","readUInt40LE","readUInt32LE","writeUInt40LE","writeInt32LE","readUInt48LE","writeUInt48LE","readUInt56LE","writeUInt56LE","readUInt64LE","writeUInt64LE","writeUInt32LE","readInt24BE","readInt8","writeInt24BE","writeInt8","readInt40BE","writeInt40BE","readInt48BE","readInt16BE","writeInt48BE","writeInt16BE","readInt56BE","writeInt56BE","readInt64BE","readInt32BE","writeInt64BE","readInt24LE","writeInt24LE","readInt40LE","writeInt40LE","readInt48LE","readInt16LE","writeInt48LE","writeInt16LE","readInt56LE","writeInt56LE","readInt64LE","readInt32LE","writeInt64LE"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/buffer-more-ints/buffer-more-ints.js"],"sourcesContent":["'use strict';\n\nvar assert = require(\"assert\");\n\n// JavaScript is numerically challenged\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// The maximum contiguous integer that can be held in a IEEE754 double\nvar MAX_INT = 0x1fffffffffffff;\n\nfunction isContiguousInt(val) {\n    return val <= MAX_INT && val >= -MAX_INT;\n}\n\nfunction assertContiguousInt(val) {\n    assert(isContiguousInt(val), \"number cannot be represented as a contiguous integer\");\n}\n\nmodule.exports.isContiguousInt = isContiguousInt;\nmodule.exports.assertContiguousInt = assertContiguousInt;\n\n// Fill in the regular procedures\n['UInt', 'Int'].forEach(function (sign) {\n  var suffix = sign + '8';\n  module.exports['read' + suffix] =\n    Buffer.prototype['read' + suffix].call;\n  module.exports['write' + suffix] =\n    Buffer.prototype['write' + suffix].call;\n  \n  ['16', '32'].forEach(function (size) {\n    ['LE', 'BE'].forEach(function (endian) {\n      var suffix = sign + size + endian;\n      var read = Buffer.prototype['read' + suffix];\n      module.exports['read' + suffix] =\n        function (buf, offset, noAssert) {\n          return read.call(buf, offset, noAssert);\n        };\n      var write = Buffer.prototype['write' + suffix];\n      module.exports['write' + suffix] =\n        function (buf, val, offset, noAssert) {\n          return write.call(buf, val, offset, noAssert);\n        };\n    });\n  });\n});\n\n// Check that a value is an integer within the given range\nfunction check_int(val, min, max) {\n    assert.ok(typeof(val) == 'number' && val >= min && val <= max && Math.floor(val) === val, \"not a number in the required range\");\n}\n\nfunction readUInt24BE(buf, offset, noAssert) {\n  return buf.readUInt8(offset, noAssert) << 16 | buf.readUInt16BE(offset + 1, noAssert);\n}\nmodule.exports.readUInt24BE = readUInt24BE;\n\nfunction writeUInt24BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt8(val >>> 16, offset, noAssert);\n    buf.writeUInt16BE(val & 0xffff, offset + 1, noAssert);\n}\nmodule.exports.writeUInt24BE = writeUInt24BE;\n\nfunction readUInt40BE(buf, offset, noAssert) {\n    return (buf.readUInt8(offset, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1, noAssert);\n}\nmodule.exports.readUInt40BE = readUInt40BE;\n\nfunction writeUInt40BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 1, noAssert);\n}\nmodule.exports.writeUInt40BE = writeUInt40BE;\n\nfunction readUInt48BE(buf, offset, noAssert) {\n    return buf.readUInt16BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2, noAssert);\n}\nmodule.exports.readUInt48BE = readUInt48BE;\n\nfunction writeUInt48BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 2, noAssert);\n}\nmodule.exports.writeUInt48BE = writeUInt48BE;\n\nfunction readUInt56BE(buf, offset, noAssert) {\n    return ((buf.readUInt8(offset, noAssert) || 0) << 16 | buf.readUInt16BE(offset + 1, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3, noAssert);\n}\nmodule.exports.readUInt56BE = readUInt56BE;\n\nfunction writeUInt56BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x100000000000000) {\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeUInt8(hi >>> 16, offset, noAssert);\n        buf.writeUInt16BE(hi & 0xffff, offset + 1, noAssert);\n        buf.writeInt32BE(val & -1, offset + 3, noAssert);\n    } else {\n        // Special case because 2^56-1 gets rounded up to 2^56\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n    }\n}\nmodule.exports.writeUInt56BE = writeUInt56BE;\n\nfunction readUInt64BE(buf, offset, noAssert) {\n    return buf.readUInt32BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4, noAssert);\n}\nmodule.exports.readUInt64BE = readUInt64BE;\n\nfunction writeUInt64BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x10000000000000000) {\n        buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n        buf.writeInt32BE(val & -1, offset + 4, noAssert);\n    } else {\n        // Special case because 2^64-1 gets rounded up to 2^64\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0xff;\n    }\n}\nmodule.exports.writeUInt64BE = writeUInt64BE;\n\nfunction readUInt24LE(buf, offset, noAssert) {\n    return buf.readUInt8(offset + 2, noAssert) << 16 | buf.readUInt16LE(offset, noAssert);\n}\nmodule.exports.readUInt24LE = readUInt24LE;\n\nfunction writeUInt24LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt16LE(val & 0xffff, offset, noAssert);\n    buf.writeUInt8(val >>> 16, offset + 2, noAssert);\n}\nmodule.exports.writeUInt24LE = writeUInt24LE;\n\nfunction readUInt40LE(buf, offset, noAssert) {\n    return (buf.readUInt8(offset + 4, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt40LE = readUInt40LE;\n\nfunction writeUInt40LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeUInt40LE = writeUInt40LE;\n\nfunction readUInt48LE(buf, offset, noAssert) {\n    return buf.readUInt16LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt48LE = readUInt48LE;\n\nfunction writeUInt48LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeUInt48LE = writeUInt48LE;\n\nfunction readUInt56LE(buf, offset, noAssert) {\n    return ((buf.readUInt8(offset + 6, noAssert) || 0) << 16 | buf.readUInt16LE(offset + 4, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt56LE = readUInt56LE;\n\nfunction writeUInt56LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x100000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeUInt16LE(hi & 0xffff, offset + 4, noAssert);\n        buf.writeUInt8(hi >>> 16, offset + 6, noAssert);\n    } else {\n        // Special case because 2^56-1 gets rounded up to 2^56\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n    }\n}\nmodule.exports.writeUInt56LE = writeUInt56LE;\n\nfunction readUInt64LE(buf, offset, noAssert) {\n    return buf.readUInt32LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt64LE = readUInt64LE;\n\nfunction writeUInt64LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x10000000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n    } else {\n        // Special case because 2^64-1 gets rounded up to 2^64\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0xff;\n    }\n}\nmodule.exports.writeUInt64LE = writeUInt64LE;\n\n\nfunction readInt24BE(buf, offset, noAssert) {\n    return (buf.readInt8(offset, noAssert) << 16) + buf.readUInt16BE(offset + 1, noAssert);\n}\nmodule.exports.readInt24BE = readInt24BE;\n\nfunction writeInt24BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000, 0x7fffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt8(val >> 16, offset, noAssert);\n    buf.writeUInt16BE(val & 0xffff, offset + 1, noAssert);\n}\nmodule.exports.writeInt24BE = writeInt24BE;\n\nfunction readInt40BE(buf, offset, noAssert) {\n    return (buf.readInt8(offset, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1, noAssert);\n}\nmodule.exports.readInt40BE = readInt40BE;\n\nfunction writeInt40BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x8000000000, 0x7fffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 1, noAssert);\n}\nmodule.exports.writeInt40BE = writeInt40BE;\n\nfunction readInt48BE(buf, offset, noAssert) {\n    return buf.readInt16BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2, noAssert);\n}\nmodule.exports.readInt48BE = readInt48BE;\n\nfunction writeInt48BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000, 0x7fffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 2, noAssert);\n}\nmodule.exports.writeInt48BE = writeInt48BE;\n\nfunction readInt56BE(buf, offset, noAssert) {\n    return (((buf.readInt8(offset, noAssert) || 0) << 16) + buf.readUInt16BE(offset + 1, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3, noAssert);\n}\nmodule.exports.readInt56BE = readInt56BE;\n\nfunction writeInt56BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000000, 0x7fffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x80000000000000) {\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeInt8(hi >> 16, offset, noAssert);\n        buf.writeUInt16BE(hi & 0xffff, offset + 1, noAssert);\n        buf.writeInt32BE(val & -1, offset + 3, noAssert);\n    } else {\n        // Special case because 2^55-1 gets rounded up to 2^55\n        buf[offset] = 0x7f;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n    }\n}\nmodule.exports.writeInt56BE = writeInt56BE;\n\nfunction readInt64BE(buf, offset, noAssert) {\n    return buf.readInt32BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4, noAssert);\n}\nmodule.exports.readInt64BE = readInt64BE;\n\nfunction writeInt64BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000000000, 0x7fffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x8000000000000000) {\n        buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n        buf.writeInt32BE(val & -1, offset + 4, noAssert);\n    } else {\n        // Special case because 2^63-1 gets rounded up to 2^63\n        buf[offset] = 0x7f;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0xff;\n    }\n}\nmodule.exports.writeInt64BE = writeInt64BE;\n\nfunction readInt24LE(buf, offset, noAssert) {\n    return (buf.readInt8(offset + 2, noAssert) << 16) + buf.readUInt16LE(offset, noAssert);\n}\nmodule.exports.readInt24LE = readInt24LE;\n\nfunction writeInt24LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000, 0x7fffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt16LE(val & 0xffff, offset, noAssert);\n    buf.writeInt8(val >> 16, offset + 2, noAssert);\n}\nmodule.exports.writeInt24LE = writeInt24LE;\n\nfunction readInt40LE(buf, offset, noAssert) {\n    return (buf.readInt8(offset + 4, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt40LE = readInt40LE;\n\nfunction writeInt40LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x8000000000, 0x7fffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeInt40LE = writeInt40LE;\n\nfunction readInt48LE(buf, offset, noAssert) {\n    return buf.readInt16LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt48LE = readInt48LE;\n\nfunction writeInt48LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000, 0x7fffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeInt48LE = writeInt48LE;\n\nfunction readInt56LE(buf, offset, noAssert) {\n    return (((buf.readInt8(offset + 6, noAssert) || 0) << 16) + buf.readUInt16LE(offset + 4, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt56LE = readInt56LE;\n\nfunction writeInt56LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x80000000000000, 0x7fffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x80000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeUInt16LE(hi & 0xffff, offset + 4, noAssert);\n        buf.writeInt8(hi >> 16, offset + 6, noAssert);\n    } else {\n        // Special case because 2^55-1 gets rounded up to 2^55\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0x7f;\n    }\n}\nmodule.exports.writeInt56LE = writeInt56LE;\n\nfunction readInt64LE(buf, offset, noAssert) {\n    return buf.readInt32LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt64LE = readInt64LE;\n\nfunction writeInt64LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x8000000000000000, 0x7fffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x8000000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n    } else {\n        // Special case because 2^55-1 gets rounded up to 2^55\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0x7f;\n    }\n}\nmodule.exports.writeInt64LE = writeInt64LE;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}