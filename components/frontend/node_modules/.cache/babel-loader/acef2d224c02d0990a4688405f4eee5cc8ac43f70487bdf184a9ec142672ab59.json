{"ast":null,"code":"//\n//\n//\n\n// A bitset implementation, after that in java.util.  Yes there\n// already exist such things, but none implement next{Clear|Set}Bit or\n// equivalent, and none involved me tooling about for an evening.\n\n'use strict';\n\nfunction BitSet(size) {\n  if (size) {\n    var numWords = Math.ceil(size / 32);\n    this.words = new Array(numWords);\n  } else {\n    this.words = [];\n  }\n  this.wordsInUse = 0; // = number, not index\n}\nvar P = BitSet.prototype;\nfunction wordIndex(bitIndex) {\n  return Math.floor(bitIndex / 32);\n}\n\n// Make sure we have at least numWords\nP.ensureSize = function (numWords) {\n  var wordsPresent = this.words.length;\n  if (wordsPresent < numWords) {\n    this.words = this.words.concat(new Array(numWords - wordsPresent));\n  }\n};\nP.set = function (bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) {\n    this.ensureSize(w + 1);\n    this.wordsInUse = w + 1;\n  }\n  var bit = 1 << bitIndex;\n  this.words[w] |= bit;\n};\nP.clear = function (bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) return;\n  var mask = ~(1 << bitIndex);\n  this.words[w] &= mask;\n};\nP.get = function (bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) return false; // >= since index vs size\n  var bit = 1 << bitIndex;\n  return !!(this.words[w] & bit);\n};\nfunction trailingZeros(i) {\n  // From Hacker's Delight, via JDK. Probably far less effective here,\n  // since bit ops are not necessarily the quick way to do things in\n  // JS.\n  if (i === 0) return 32;\n  var y,\n    n = 31;\n  y = i << 16;\n  if (y != 0) {\n    n = n - 16;\n    i = y;\n  }\n  y = i << 8;\n  if (y != 0) {\n    n = n - 8;\n    i = y;\n  }\n  y = i << 4;\n  if (y != 0) {\n    n = n - 4;\n    i = y;\n  }\n  y = i << 2;\n  if (y != 0) {\n    n = n - 2;\n    i = y;\n  }\n  return n - (i << 1 >>> 31);\n}\n\n// Give the next bit that's set on or after fromIndex, or -1 if no such\n// bit\nP.nextSetBit = function (fromIndex) {\n  var w = wordIndex(fromIndex);\n  if (w >= this.wordsInUse) return -1;\n\n  // the right-hand side is shifted to only test the bits of the first\n  // word that are > fromIndex\n  var word = this.words[w] & 0xffffffff << fromIndex;\n  while (true) {\n    if (word) return w * 32 + trailingZeros(word);\n    w++;\n    if (w === this.wordsInUse) return -1;\n    word = this.words[w];\n  }\n};\nP.nextClearBit = function (fromIndex) {\n  var w = wordIndex(fromIndex);\n  if (w >= this.wordsInUse) return fromIndex;\n  var word = ~this.words[w] & 0xffffffff << fromIndex;\n  while (true) {\n    if (word) return w * 32 + trailingZeros(word);\n    w++;\n    if (w == this.wordsInUse) return w * 32;\n    word = ~this.words[w];\n  }\n};\nmodule.exports.BitSet = BitSet;","map":{"version":3,"names":["BitSet","size","numWords","Math","ceil","words","Array","wordsInUse","P","prototype","wordIndex","bitIndex","floor","ensureSize","wordsPresent","length","concat","set","w","bit","clear","mask","get","trailingZeros","i","y","n","nextSetBit","fromIndex","word","nextClearBit","module","exports"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/amqplib/lib/bitset.js"],"sourcesContent":["//\n//\n//\n\n// A bitset implementation, after that in java.util.  Yes there\n// already exist such things, but none implement next{Clear|Set}Bit or\n// equivalent, and none involved me tooling about for an evening.\n\n'use strict';\n\nfunction BitSet(size) {\n  if (size) {\n    var numWords = Math.ceil(size / 32);\n    this.words = new Array(numWords);\n  }\n  else {\n    this.words = [];\n  }\n  this.wordsInUse = 0; // = number, not index\n}\n\nvar P = BitSet.prototype;\n\nfunction wordIndex(bitIndex) {\n  return Math.floor(bitIndex / 32);\n}\n\n// Make sure we have at least numWords\nP.ensureSize = function(numWords) {\n  var wordsPresent = this.words.length;\n  if (wordsPresent < numWords) {\n    this.words = this.words.concat(new Array(numWords - wordsPresent));\n  }\n}\n\nP.set = function(bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) {\n    this.ensureSize(w + 1);\n    this.wordsInUse = w + 1;\n  }\n  var bit = 1 << bitIndex;\n  this.words[w] |= bit;\n};\n\nP.clear = function(bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) return;\n  var mask = ~(1 << bitIndex);\n  this.words[w] &= mask;\n};\n\nP.get = function(bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) return false; // >= since index vs size\n  var bit = 1 << bitIndex;\n  return !!(this.words[w] & bit);\n}\n\nfunction trailingZeros(i) {\n  // From Hacker's Delight, via JDK. Probably far less effective here,\n  // since bit ops are not necessarily the quick way to do things in\n  // JS.\n  if (i === 0) return 32;\n  var y, n = 31;\n  y = i << 16; if (y != 0) { n = n -16; i = y; }\n  y = i << 8;  if (y != 0) { n = n - 8; i = y; }\n  y = i << 4;  if (y != 0) { n = n - 4; i = y; }\n  y = i << 2;  if (y != 0) { n = n - 2; i = y; }\n  return n - ((i << 1) >>> 31);\n}\n\n// Give the next bit that's set on or after fromIndex, or -1 if no such\n// bit\nP.nextSetBit = function(fromIndex) {\n  var w = wordIndex(fromIndex);\n  if (w >= this.wordsInUse) return -1;\n\n  // the right-hand side is shifted to only test the bits of the first\n  // word that are > fromIndex\n  var word = this.words[w] & (0xffffffff << fromIndex);\n  while (true) {\n    if (word) return (w * 32) + trailingZeros(word);\n    w++;\n    if (w === this.wordsInUse) return -1;\n    word = this.words[w];\n  }\n};\n\nP.nextClearBit = function(fromIndex) {\n  var w = wordIndex(fromIndex);\n  if (w >= this.wordsInUse) return fromIndex;\n\n  var word = ~(this.words[w]) & (0xffffffff << fromIndex);\n  while (true) {\n    if (word) return (w * 32) + trailingZeros(word);\n    w++;\n    if (w == this.wordsInUse) return w * 32;\n    word = ~(this.words[w]);\n  }\n};\n\nmodule.exports.BitSet = BitSet;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}