{"ast":null,"code":"/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nvar constants = require('constants');\nvar SIGN_INFO_HEAD = {\n  md2: new Buffer('3020300c06082a864886f70d020205000410', 'hex'),\n  md5: new Buffer('3020300c06082a864886f70d020505000410', 'hex'),\n  sha1: new Buffer('3021300906052b0e03021a05000414', 'hex'),\n  sha224: new Buffer('302d300d06096086480165030402040500041c', 'hex'),\n  sha256: new Buffer('3031300d060960864801650304020105000420', 'hex'),\n  sha384: new Buffer('3041300d060960864801650304020205000430', 'hex'),\n  sha512: new Buffer('3051300d060960864801650304020305000440', 'hex'),\n  ripemd160: new Buffer('3021300906052b2403020105000414', 'hex'),\n  rmd160: new Buffer('3021300906052b2403020105000414', 'hex')\n};\nvar SIGN_ALG_TO_HASH_ALIASES = {\n  'ripemd160': 'rmd160'\n};\nvar DEFAULT_HASH_FUNCTION = 'sha256';\nmodule.exports = {\n  isEncryption: true,\n  isSignature: true\n};\nmodule.exports.makeScheme = function (key, options) {\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n  Scheme.prototype.maxMessageLength = function () {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      return this.key.encryptedDataLength;\n    }\n    return this.key.encryptedDataLength - 11;\n  };\n\n  /**\n   * Pad input Buffer to encryptedDataLength bytes, and return new Buffer\n   * alg: PKCS#1\n   * @param buffer\n   * @returns {Buffer}\n   */\n  Scheme.prototype.encPad = function (buffer, options) {\n    options = options || {};\n    var filled;\n    if (buffer.length > this.key.maxMessageLength) {\n      throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n    }\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      return this.pkcs0pad(buffer);\n    }\n\n    /* Type 1: zeros padding for private key encrypt */\n    if (options.type === 1) {\n      filled = new Buffer(this.key.encryptedDataLength - buffer.length - 1);\n      filled.fill(0xff, 0, filled.length - 1);\n      filled[0] = 1;\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    } else {\n      /* random padding for public key encrypt */\n      filled = new Buffer(this.key.encryptedDataLength - buffer.length);\n      filled[0] = 0;\n      filled[1] = 2;\n      var rand = crypt.randomBytes(filled.length - 3);\n      for (var i = 0; i < rand.length; i++) {\n        var r = rand[i];\n        while (r === 0) {\n          // non-zero only\n          r = crypt.randomBytes(1)[0];\n        }\n        filled[i + 2] = r;\n      }\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    }\n  };\n\n  /**\n   * Unpad input Buffer and, if valid, return the Buffer object\n   * alg: PKCS#1 (type 2, random)\n   * @param buffer\n   * @returns {Buffer}\n   */\n  Scheme.prototype.encUnPad = function (buffer, options) {\n    options = options || {};\n    var i = 0;\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      return this.pkcs0unpad(buffer);\n    }\n    if (buffer.length < 4) {\n      return null;\n    }\n\n    /* Type 1: zeros padding for private key decrypt */\n    if (options.type === 1) {\n      if (buffer[0] !== 0 && buffer[1] !== 1) {\n        return null;\n      }\n      i = 3;\n      while (buffer[i] !== 0) {\n        if (buffer[i] != 0xFF || ++i >= buffer.length) {\n          return null;\n        }\n      }\n    } else {\n      /* random padding for public key decrypt */\n      if (buffer[0] !== 0 && buffer[1] !== 2) {\n        return null;\n      }\n      i = 3;\n      while (buffer[i] !== 0) {\n        if (++i >= buffer.length) {\n          return null;\n        }\n      }\n    }\n    return buffer.slice(i + 1, buffer.length);\n  };\n  Scheme.prototype.sign = function (buffer) {\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n      return res;\n    } else {\n      var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n      signer.update(buffer);\n      return signer.sign(this.options.rsaUtils.exportKey('private'));\n    }\n  };\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING has no verify data\n      return false;\n    }\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      if (signature_encoding) {\n        signature = new Buffer(signature, signature_encoding);\n      }\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var m = this.key.$doPublic(new BigInteger(signature));\n      return m.toBuffer().toString('hex') == hash.toString('hex');\n    } else {\n      var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n      verifier.update(buffer);\n      return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n    }\n  };\n\n  /**\n   * PKCS#1 zero pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n  Scheme.prototype.pkcs0pad = function (buffer) {\n    var filled = new Buffer(this.key.maxMessageLength - buffer.length);\n    filled.fill(0);\n    return Buffer.concat([filled, buffer]);\n    return filled;\n  };\n  Scheme.prototype.pkcs0unpad = function (buffer) {\n    var unPad;\n    if (typeof buffer.lastIndexOf == \"function\") {\n      //patch for old node version\n      unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n    } else {\n      unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n    }\n    return unPad;\n  };\n\n  /**\n   * PKCS#1 pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n  Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n    var digest = SIGN_INFO_HEAD[hashAlgorithm];\n    if (!digest) {\n      throw Error('Unsupported hash algorithm');\n    }\n    var data = Buffer.concat([digest, hashBuf]);\n    if (data.length + 10 > this.key.encryptedDataLength) {\n      throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n    }\n    var filled = new Buffer(this.key.encryptedDataLength - data.length - 1);\n    filled.fill(0xff, 0, filled.length - 1);\n    filled[0] = 1;\n    filled[filled.length - 1] = 0;\n    var res = Buffer.concat([filled, data]);\n    return res;\n  };\n  return new Scheme(key, options);\n};","map":{"version":3,"names":["BigInteger","require","crypt","constants","SIGN_INFO_HEAD","md2","Buffer","md5","sha1","sha224","sha256","sha384","sha512","ripemd160","rmd160","SIGN_ALG_TO_HASH_ALIASES","DEFAULT_HASH_FUNCTION","module","exports","isEncryption","isSignature","makeScheme","key","options","Scheme","prototype","maxMessageLength","encryptionSchemeOptions","padding","RSA_NO_PADDING","encryptedDataLength","encPad","buffer","filled","length","Error","pkcs0pad","type","fill","concat","rand","randomBytes","i","r","encUnPad","pkcs0unpad","slice","sign","hashAlgorithm","signingSchemeOptions","hash","environment","hasher","createHash","update","pkcs1pad","digest","res","$doPrivate","toBuffer","signer","createSign","toUpperCase","rsaUtils","exportKey","verify","signature","signature_encoding","m","$doPublic","toString","verifier","createVerify","unPad","lastIndexOf","String","call","hashBuf","data"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/node-rsa/src/schemes/pkcs1.js"],"sourcesContent":["/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nvar constants = require('constants');\nvar SIGN_INFO_HEAD = {\n    md2: new Buffer('3020300c06082a864886f70d020205000410', 'hex'),\n    md5: new Buffer('3020300c06082a864886f70d020505000410', 'hex'),\n    sha1: new Buffer('3021300906052b0e03021a05000414', 'hex'),\n    sha224: new Buffer('302d300d06096086480165030402040500041c', 'hex'),\n    sha256: new Buffer('3031300d060960864801650304020105000420', 'hex'),\n    sha384: new Buffer('3041300d060960864801650304020205000430', 'hex'),\n    sha512: new Buffer('3051300d060960864801650304020305000440', 'hex'),\n    ripemd160: new Buffer('3021300906052b2403020105000414', 'hex'),\n    rmd160: new Buffer('3021300906052b2403020105000414', 'hex')\n};\n\nvar SIGN_ALG_TO_HASH_ALIASES = {\n    'ripemd160': 'rmd160'\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha256';\n\nmodule.exports = {\n    isEncryption: true,\n    isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.maxMessageLength = function () {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            return this.key.encryptedDataLength;\n        }\n        return this.key.encryptedDataLength - 11;\n    };\n\n    /**\n     * Pad input Buffer to encryptedDataLength bytes, and return new Buffer\n     * alg: PKCS#1\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encPad = function (buffer, options) {\n        options = options || {};\n        var filled;\n        if (buffer.length > this.key.maxMessageLength) {\n            throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n        }\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            return this.pkcs0pad(buffer);\n        }\n\n        /* Type 1: zeros padding for private key encrypt */\n        if (options.type === 1) {\n            filled = new Buffer(this.key.encryptedDataLength - buffer.length - 1);\n            filled.fill(0xff, 0, filled.length - 1);\n            filled[0] = 1;\n            filled[filled.length - 1] = 0;\n\n            return Buffer.concat([filled, buffer]);\n        } else {\n            /* random padding for public key encrypt */\n            filled = new Buffer(this.key.encryptedDataLength - buffer.length);\n            filled[0] = 0;\n            filled[1] = 2;\n            var rand = crypt.randomBytes(filled.length - 3);\n            for (var i = 0; i < rand.length; i++) {\n                var r = rand[i];\n                while (r === 0) { // non-zero only\n                    r = crypt.randomBytes(1)[0];\n                }\n                filled[i + 2] = r;\n            }\n            filled[filled.length - 1] = 0;\n            return Buffer.concat([filled, buffer]);\n        }\n    };\n\n    /**\n     * Unpad input Buffer and, if valid, return the Buffer object\n     * alg: PKCS#1 (type 2, random)\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encUnPad = function (buffer, options) {\n        options = options || {};\n        var i = 0;\n\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            return this.pkcs0unpad(buffer);\n        }\n\n        if (buffer.length < 4) {\n            return null;\n        }\n\n        /* Type 1: zeros padding for private key decrypt */\n        if (options.type === 1) {\n            if (buffer[0] !== 0 && buffer[1] !== 1) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (buffer[i] != 0xFF || ++i >= buffer.length) {\n                    return null;\n                }\n            }\n        } else {\n            /* random padding for public key decrypt */\n            if (buffer[0] !== 0 && buffer[1] !== 2) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (++i >= buffer.length) {\n                    return null;\n                }\n            }\n        }\n        return buffer.slice(i + 1, buffer.length);\n    };\n\n    Scheme.prototype.sign = function (buffer) {\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n\n            return res;\n        } else {\n            var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n            signer.update(buffer);\n            return signer.sign(this.options.rsaUtils.exportKey('private'));\n        }\n    };\n\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING has no verify data\n            return false;\n        }\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            if (signature_encoding) {\n                signature = new Buffer(signature, signature_encoding);\n            }\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var m = this.key.$doPublic(new BigInteger(signature));\n\n            return m.toBuffer().toString('hex') == hash.toString('hex');\n        } else {\n            var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n            verifier.update(buffer);\n            return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n        }\n    };\n\n    /**\n     * PKCS#1 zero pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs0pad = function (buffer) {\n        var filled = new Buffer(this.key.maxMessageLength - buffer.length);\n        filled.fill(0);\n        return Buffer.concat([filled, buffer]);\n\n        return filled;\n    };\n\n    Scheme.prototype.pkcs0unpad = function (buffer) {\n        var unPad;\n        if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n            unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n        } else {\n            unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n        }\n\n        return unPad;\n    };\n\n    /**\n     * PKCS#1 pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n        var digest = SIGN_INFO_HEAD[hashAlgorithm];\n        if (!digest) {\n            throw Error('Unsupported hash algorithm');\n        }\n\n        var data = Buffer.concat([digest, hashBuf]);\n\n        if (data.length + 10 > this.key.encryptedDataLength) {\n            throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n        }\n\n        var filled = new Buffer(this.key.encryptedDataLength - data.length - 1);\n        filled.fill(0xff, 0, filled.length - 1);\n        filled[0] = 1;\n        filled[filled.length - 1] = 0;\n\n        var res = Buffer.concat([filled, data]);\n\n        return res;\n    };\n\n    return new Scheme(key, options);\n};\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}