{"ast":null,"code":"/**\n * PSS signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nmodule.exports = {\n  isEncryption: false,\n  isSignature: true\n};\nvar DEFAULT_HASH_FUNCTION = 'sha1';\nvar DEFAULT_SALT_LENGTH = 20;\nmodule.exports.makeScheme = function (key, options) {\n  var OAEP = require('./schemes').pkcs1_oaep;\n\n  /**\n   * @param key\n   * @param options\n   * options    [Object]    An object that contains the following keys that specify certain options for encoding.\n   *  └>signingSchemeOptions\n   *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\n   *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\n   *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\n   * @constructor\n   */\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n  Scheme.prototype.sign = function (buffer) {\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\n    return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\n  };\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (signature_encoding) {\n      signature = new Buffer(signature, signature_encoding);\n    }\n    signature = new BigInteger(signature);\n    var emLen = Math.ceil((this.key.keySize - 1) / 8);\n    var m = this.key.$doPublic(signature).toBuffer(emLen);\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\n  };\n\n  /*\n   * https://tools.ietf.org/html/rfc3447#section-9.1.1\n   *\n   * mHash\t[Buffer]\tHashed message to encode\n   * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\n   * @returns {Buffer} The encoded message\n   */\n  Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n    if (emLen < hLen + sLen + 2) {\n      throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" + \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" + (8 * hLen + 8 * sLen + 9) + \")\");\n    }\n    var salt = crypt.randomBytes(sLen);\n    var Mapostrophe = new Buffer(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var H = crypt.createHash(hash);\n    H.update(Mapostrophe);\n    H = H.digest();\n    var PS = new Buffer(emLen - salt.length - hLen - 2);\n    PS.fill(0);\n    var DB = new Buffer(PS.length + 1 + salt.length);\n    PS.copy(DB);\n    DB[PS.length] = 0x01;\n    salt.copy(DB, PS.length + 1);\n    var dbMask = mgf(H, DB.length, hash);\n\n    // XOR DB and dbMask together\n    var maskedDB = new Buffer(DB.length);\n    for (var i = 0; i < dbMask.length; i++) {\n      maskedDB[i] = DB[i] ^ dbMask[i];\n    }\n    var bits = 8 * emLen - emBits;\n    var mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    maskedDB[0] = maskedDB[0] & mask;\n    var EM = new Buffer(maskedDB.length + H.length + 1);\n    maskedDB.copy(EM, 0);\n    H.copy(EM, maskedDB.length);\n    EM[EM.length - 1] = 0xbc;\n    return EM;\n  };\n\n  /*\n   * https://tools.ietf.org/html/rfc3447#section-9.1.2\n   *\n   * mHash\t[Buffer]\tHashed message\n   * EM\t\t[Buffer]\tSignature\n   * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\n   * @returns {Boolean} True if signature(EM) matches message(M)\n   */\n  Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n    if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\n      return false;\n    }\n    var DB = new Buffer(emLen - hLen - 1);\n    EM.copy(DB, 0, 0, emLen - hLen - 1);\n    var mask = 0;\n    for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\n      mask |= 1 << 7 - i;\n    }\n    if ((DB[0] & mask) !== 0) {\n      return false;\n    }\n    var H = EM.slice(emLen - hLen - 1, emLen - 1);\n    var dbMask = mgf(H, DB.length, hash);\n\n    // Unmask DB\n    for (i = 0; i < DB.length; i++) {\n      DB[i] ^= dbMask[i];\n    }\n    bits = 8 * emLen - emBits;\n    mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    DB[0] = DB[0] & mask;\n\n    // Filter out padding\n    for (i = 0; DB[i] === 0 && i < DB.length; i++);\n    if (DB[i] != 1) {\n      return false;\n    }\n    var salt = DB.slice(DB.length - sLen);\n    var Mapostrophe = new Buffer(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var Hapostrophe = crypt.createHash(hash);\n    Hapostrophe.update(Mapostrophe);\n    Hapostrophe = Hapostrophe.digest();\n    return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\n  };\n  return new Scheme(key, options);\n};","map":{"version":3,"names":["BigInteger","require","crypt","module","exports","isEncryption","isSignature","DEFAULT_HASH_FUNCTION","DEFAULT_SALT_LENGTH","makeScheme","key","options","OAEP","pkcs1_oaep","Scheme","prototype","sign","buffer","mHash","createHash","signingSchemeOptions","hash","update","encoded","emsa_pss_encode","digest","keySize","$doPrivate","toBuffer","encryptedDataLength","verify","signature","signature_encoding","Buffer","emLen","Math","ceil","m","$doPublic","emsa_pss_verify","emBits","mgf","eme_oaep_mgf1","sLen","saltLength","hLen","digestLength","Error","salt","randomBytes","Mapostrophe","fill","copy","length","H","PS","DB","dbMask","maskedDB","i","bits","mask","EM","slice","Hapostrophe","toString"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/node-rsa/src/schemes/pss.js"],"sourcesContent":["/**\n * PSS signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\n\nmodule.exports = {\n    isEncryption: false,\n    isSignature: true\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha1';\nvar DEFAULT_SALT_LENGTH = 20;\n\nmodule.exports.makeScheme = function (key, options) {\n    var OAEP = require('./schemes').pkcs1_oaep;\n\n    /**\n     * @param key\n     * @param options\n     * options    [Object]    An object that contains the following keys that specify certain options for encoding.\n     *  └>signingSchemeOptions\n     *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\n     *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\n     *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\n     * @constructor\n     */\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.sign = function (buffer) {\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n        mHash.update(buffer);\n\n        var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\n        return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\n    };\n\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n        if (signature_encoding) {\n            signature = new Buffer(signature, signature_encoding);\n        }\n        signature = new BigInteger(signature);\n\n        var emLen = Math.ceil((this.key.keySize - 1) / 8);\n        var m = this.key.$doPublic(signature).toBuffer(emLen);\n\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n        mHash.update(buffer);\n\n        return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\n    };\n\n    /*\n     * https://tools.ietf.org/html/rfc3447#section-9.1.1\n     *\n     * mHash\t[Buffer]\tHashed message to encode\n     * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\n     * @returns {Buffer} The encoded message\n     */\n    Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n\n        var hLen = OAEP.digestLength[hash];\n        var emLen = Math.ceil(emBits / 8);\n\n        if (emLen < hLen + sLen + 2) {\n            throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" +\n                \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" +\n                (8 * hLen + 8 * sLen + 9) + \")\"\n            );\n        }\n\n        var salt = crypt.randomBytes(sLen);\n\n        var Mapostrophe = new Buffer(8 + hLen + sLen);\n        Mapostrophe.fill(0, 0, 8);\n        mHash.copy(Mapostrophe, 8);\n        salt.copy(Mapostrophe, 8 + mHash.length);\n\n        var H = crypt.createHash(hash);\n        H.update(Mapostrophe);\n        H = H.digest();\n\n        var PS = new Buffer(emLen - salt.length - hLen - 2);\n        PS.fill(0);\n\n        var DB = new Buffer(PS.length + 1 + salt.length);\n        PS.copy(DB);\n        DB[PS.length] = 0x01;\n        salt.copy(DB, PS.length + 1);\n\n        var dbMask = mgf(H, DB.length, hash);\n\n        // XOR DB and dbMask together\n        var maskedDB = new Buffer(DB.length);\n        for (var i = 0; i < dbMask.length; i++) {\n            maskedDB[i] = DB[i] ^ dbMask[i];\n        }\n\n        var bits = 8 * emLen - emBits;\n        var mask = 255 ^ (255 >> 8 - bits << 8 - bits);\n        maskedDB[0] = maskedDB[0] & mask;\n\n        var EM = new Buffer(maskedDB.length + H.length + 1);\n        maskedDB.copy(EM, 0);\n        H.copy(EM, maskedDB.length);\n        EM[EM.length - 1] = 0xbc;\n\n        return EM;\n    };\n\n    /*\n     * https://tools.ietf.org/html/rfc3447#section-9.1.2\n     *\n     * mHash\t[Buffer]\tHashed message\n     * EM\t\t[Buffer]\tSignature\n     * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\n     * @returns {Boolean} True if signature(EM) matches message(M)\n     */\n    Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n\n        var hLen = OAEP.digestLength[hash];\n        var emLen = Math.ceil(emBits / 8);\n\n        if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\n            return false;\n        }\n\n        var DB = new Buffer(emLen - hLen - 1);\n        EM.copy(DB, 0, 0, emLen - hLen - 1);\n\n        var mask = 0;\n        for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\n            mask |= 1 << (7 - i);\n        }\n\n        if ((DB[0] & mask) !== 0) {\n            return false;\n        }\n\n        var H = EM.slice(emLen - hLen - 1, emLen - 1);\n        var dbMask = mgf(H, DB.length, hash);\n\n        // Unmask DB\n        for (i = 0; i < DB.length; i++) {\n            DB[i] ^= dbMask[i];\n        }\n\n        bits = 8 * emLen - emBits;\n        mask = 255 ^ (255 >> 8 - bits << 8 - bits);\n        DB[0] = DB[0] & mask;\n\n        // Filter out padding\n        for (i = 0; DB[i] === 0 && i < DB.length; i++);\n        if (DB[i] != 1) {\n            return false;\n        }\n\n        var salt = DB.slice(DB.length - sLen);\n\n        var Mapostrophe = new Buffer(8 + hLen + sLen);\n        Mapostrophe.fill(0, 0, 8);\n        mHash.copy(Mapostrophe, 8);\n        salt.copy(Mapostrophe, 8 + mHash.length);\n\n        var Hapostrophe = crypt.createHash(hash);\n        Hapostrophe.update(Mapostrophe);\n        Hapostrophe = Hapostrophe.digest();\n\n        return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\n    };\n\n    return new Scheme(key, options);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}