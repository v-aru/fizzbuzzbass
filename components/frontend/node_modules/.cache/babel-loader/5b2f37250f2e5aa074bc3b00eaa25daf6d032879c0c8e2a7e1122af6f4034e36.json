{"ast":null,"code":"// The river sweeps through\n// Silt and twigs, gravel and leaves\n// Driving the wheel on\n\n'use strict';\n\nvar defs = require('./defs');\nvar constants = defs.constants;\nvar decode = defs.decode;\nvar Buffer = require('safe-buffer').Buffer;\nvar Bits = require('bitsyntax');\nmodule.exports.PROTOCOL_HEADER = \"AMQP\" + String.fromCharCode(0, 0, 9, 1);\n\n/*\n  Frame format:\n\n  0      1         3             7                size+7 size+8\n  +------+---------+-------------+ +------------+ +-----------+\n  | type | channel | size        | | payload    | | frame-end |\n  +------+---------+-------------+ +------------+ +-----------+\n  octet   short     long            size octets    octet\n\n  In general I want to know those first three things straight away, so I\n  can discard frames early.\n\n*/\n\n// framing constants\nvar FRAME_METHOD = constants.FRAME_METHOD,\n  FRAME_HEARTBEAT = constants.FRAME_HEARTBEAT,\n  FRAME_HEADER = constants.FRAME_HEADER,\n  FRAME_BODY = constants.FRAME_BODY,\n  FRAME_END = constants.FRAME_END;\nvar bodyCons = Bits.builder(FRAME_BODY, 'channel:16, size:32, payload:size/binary', FRAME_END);\n\n// %%% TESTME possibly better to cons the first bit and write the\n// second directly, in the absence of IO lists\nmodule.exports.makeBodyFrame = function (channel, payload) {\n  return bodyCons({\n    channel: channel,\n    size: payload.length,\n    payload: payload\n  });\n};\nvar frameHeaderPattern = Bits.matcher('type:8', 'channel:16', 'size:32', 'rest/binary');\nfunction parseFrame(bin, max) {\n  var fh = frameHeaderPattern(bin);\n  if (fh) {\n    var size = fh.size,\n      rest = fh.rest;\n    if (size > max) {\n      throw new Error('Frame size exceeds frame max');\n    } else if (rest.length > size) {\n      if (rest[size] !== FRAME_END) throw new Error('Invalid frame');\n      return {\n        type: fh.type,\n        channel: fh.channel,\n        size: size,\n        payload: rest.slice(0, size),\n        rest: rest.slice(size + 1)\n      };\n    }\n  }\n  return false;\n}\nmodule.exports.parseFrame = parseFrame;\nvar headerPattern = Bits.matcher('class:16', '_weight:16', 'size:64', 'flagsAndfields/binary');\nvar methodPattern = Bits.matcher('id:32, args/binary');\nvar HEARTBEAT = {\n  channel: 0\n};\nmodule.exports.decodeFrame = function (frame) {\n  var payload = frame.payload;\n  switch (frame.type) {\n    case FRAME_METHOD:\n      var idAndArgs = methodPattern(payload);\n      var id = idAndArgs.id;\n      var fields = decode(id, idAndArgs.args);\n      return {\n        id: id,\n        channel: frame.channel,\n        fields: fields\n      };\n    case FRAME_HEADER:\n      var parts = headerPattern(payload);\n      var id = parts['class'];\n      var fields = decode(id, parts.flagsAndfields);\n      return {\n        id: id,\n        channel: frame.channel,\n        size: parts.size,\n        fields: fields\n      };\n    case FRAME_BODY:\n      return {\n        channel: frame.channel,\n        content: frame.payload\n      };\n    case FRAME_HEARTBEAT:\n      return HEARTBEAT;\n    default:\n      throw new Error('Unknown frame type ' + frame.type);\n  }\n};\n\n// encoded heartbeat\nmodule.exports.HEARTBEAT_BUF = Buffer.from([constants.FRAME_HEARTBEAT, 0, 0, 0, 0,\n// size = 0\n0, 0,\n// channel = 0\nconstants.FRAME_END]);\nmodule.exports.HEARTBEAT = HEARTBEAT;","map":{"version":3,"names":["defs","require","constants","decode","Buffer","Bits","module","exports","PROTOCOL_HEADER","String","fromCharCode","FRAME_METHOD","FRAME_HEARTBEAT","FRAME_HEADER","FRAME_BODY","FRAME_END","bodyCons","builder","makeBodyFrame","channel","payload","size","length","frameHeaderPattern","matcher","parseFrame","bin","max","fh","rest","Error","type","slice","headerPattern","methodPattern","HEARTBEAT","decodeFrame","frame","idAndArgs","id","fields","args","parts","flagsAndfields","content","HEARTBEAT_BUF","from"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/amqplib/lib/frame.js"],"sourcesContent":["// The river sweeps through\n// Silt and twigs, gravel and leaves\n// Driving the wheel on\n\n'use strict';\n\nvar defs = require('./defs');\nvar constants = defs.constants;\nvar decode = defs.decode;\nvar Buffer = require('safe-buffer').Buffer\n\nvar Bits = require('bitsyntax');\n\nmodule.exports.PROTOCOL_HEADER = \"AMQP\" + String.fromCharCode(0, 0, 9, 1);\n\n/*\n  Frame format:\n\n  0      1         3             7                size+7 size+8\n  +------+---------+-------------+ +------------+ +-----------+\n  | type | channel | size        | | payload    | | frame-end |\n  +------+---------+-------------+ +------------+ +-----------+\n  octet   short     long            size octets    octet\n\n  In general I want to know those first three things straight away, so I\n  can discard frames early.\n\n*/\n\n// framing constants\nvar FRAME_METHOD = constants.FRAME_METHOD,\nFRAME_HEARTBEAT = constants.FRAME_HEARTBEAT,\nFRAME_HEADER = constants.FRAME_HEADER,\nFRAME_BODY = constants.FRAME_BODY,\nFRAME_END = constants.FRAME_END;\n\nvar bodyCons =\n  Bits.builder(FRAME_BODY,\n               'channel:16, size:32, payload:size/binary',\n               FRAME_END);\n\n// %%% TESTME possibly better to cons the first bit and write the\n// second directly, in the absence of IO lists\nmodule.exports.makeBodyFrame = function(channel, payload) {\n  return bodyCons({channel: channel, size: payload.length, payload: payload});\n};\n\nvar frameHeaderPattern = Bits.matcher('type:8', 'channel:16',\n                                      'size:32', 'rest/binary');\n\nfunction parseFrame(bin, max) {\n  var fh = frameHeaderPattern(bin);\n  if (fh) {\n    var size = fh.size, rest = fh.rest;\n    if (size > max) {\n      throw new Error('Frame size exceeds frame max');\n    }\n    else if (rest.length > size) {\n      if (rest[size] !== FRAME_END)\n        throw new Error('Invalid frame');\n\n      return {\n        type: fh.type,\n        channel: fh.channel,\n        size: size,\n        payload: rest.slice(0, size),\n        rest: rest.slice(size + 1)\n      };\n    }\n  }\n  return false;\n}\n\nmodule.exports.parseFrame = parseFrame;\n\nvar headerPattern = Bits.matcher('class:16',\n                                 '_weight:16',\n                                 'size:64',\n                                 'flagsAndfields/binary');\n\nvar methodPattern = Bits.matcher('id:32, args/binary');\n\nvar HEARTBEAT = {channel: 0};\n\nmodule.exports.decodeFrame = function(frame) {\n  var payload = frame.payload;\n  switch (frame.type) {\n  case FRAME_METHOD:\n    var idAndArgs = methodPattern(payload);\n    var id = idAndArgs.id;\n    var fields = decode(id, idAndArgs.args);\n    return {id: id, channel: frame.channel, fields: fields};\n  case FRAME_HEADER:\n    var parts = headerPattern(payload);\n    var id = parts['class'];\n    var fields = decode(id, parts.flagsAndfields);\n    return {id: id, channel: frame.channel,\n            size: parts.size, fields: fields};\n  case FRAME_BODY:\n    return {channel: frame.channel, content: frame.payload};\n  case FRAME_HEARTBEAT:\n    return HEARTBEAT;\n  default:\n    throw new Error('Unknown frame type ' + frame.type);\n  }\n}\n\n// encoded heartbeat\nmodule.exports.HEARTBEAT_BUF = Buffer.from([constants.FRAME_HEARTBEAT,\n                                           0, 0, 0, 0, // size = 0\n                                           0, 0, // channel = 0\n                                           constants.FRAME_END]);\n\nmodule.exports.HEARTBEAT = HEARTBEAT;\n"],"mappings":"AAAA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC5B,IAAIC,SAAS,GAAGF,IAAI,CAACE,SAAS;AAC9B,IAAIC,MAAM,GAAGH,IAAI,CAACG,MAAM;AACxB,IAAIC,MAAM,GAAGH,OAAO,CAAC,aAAa,CAAC,CAACG,MAAM;AAE1C,IAAIC,IAAI,GAAGJ,OAAO,CAAC,WAAW,CAAC;AAE/BK,MAAM,CAACC,OAAO,CAACC,eAAe,GAAG,MAAM,GAAGC,MAAM,CAACC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAIC,YAAY,GAAGT,SAAS,CAACS,YAAY;EACzCC,eAAe,GAAGV,SAAS,CAACU,eAAe;EAC3CC,YAAY,GAAGX,SAAS,CAACW,YAAY;EACrCC,UAAU,GAAGZ,SAAS,CAACY,UAAU;EACjCC,SAAS,GAAGb,SAAS,CAACa,SAAS;AAE/B,IAAIC,QAAQ,GACVX,IAAI,CAACY,OAAO,CAACH,UAAU,EACV,0CAA0C,EAC1CC,SAAS,CAAC;;AAEzB;AACA;AACAT,MAAM,CAACC,OAAO,CAACW,aAAa,GAAG,UAASC,OAAO,EAAEC,OAAO,EAAE;EACxD,OAAOJ,QAAQ,CAAC;IAACG,OAAO,EAAEA,OAAO;IAAEE,IAAI,EAAED,OAAO,CAACE,MAAM;IAAEF,OAAO,EAAEA;EAAO,CAAC,CAAC;AAC7E,CAAC;AAED,IAAIG,kBAAkB,GAAGlB,IAAI,CAACmB,OAAO,CAAC,QAAQ,EAAE,YAAY,EACtB,SAAS,EAAE,aAAa,CAAC;AAE/D,SAASC,UAAUA,CAACC,GAAG,EAAEC,GAAG,EAAE;EAC5B,IAAIC,EAAE,GAAGL,kBAAkB,CAACG,GAAG,CAAC;EAChC,IAAIE,EAAE,EAAE;IACN,IAAIP,IAAI,GAAGO,EAAE,CAACP,IAAI;MAAEQ,IAAI,GAAGD,EAAE,CAACC,IAAI;IAClC,IAAIR,IAAI,GAAGM,GAAG,EAAE;MACd,MAAM,IAAIG,KAAK,CAAC,8BAA8B,CAAC;IACjD,CAAC,MACI,IAAID,IAAI,CAACP,MAAM,GAAGD,IAAI,EAAE;MAC3B,IAAIQ,IAAI,CAACR,IAAI,CAAC,KAAKN,SAAS,EAC1B,MAAM,IAAIe,KAAK,CAAC,eAAe,CAAC;MAElC,OAAO;QACLC,IAAI,EAAEH,EAAE,CAACG,IAAI;QACbZ,OAAO,EAAES,EAAE,CAACT,OAAO;QACnBE,IAAI,EAAEA,IAAI;QACVD,OAAO,EAAES,IAAI,CAACG,KAAK,CAAC,CAAC,EAAEX,IAAI,CAAC;QAC5BQ,IAAI,EAAEA,IAAI,CAACG,KAAK,CAACX,IAAI,GAAG,CAAC;MAC3B,CAAC;IACH;EACF;EACA,OAAO,KAAK;AACd;AAEAf,MAAM,CAACC,OAAO,CAACkB,UAAU,GAAGA,UAAU;AAEtC,IAAIQ,aAAa,GAAG5B,IAAI,CAACmB,OAAO,CAAC,UAAU,EACV,YAAY,EACZ,SAAS,EACT,uBAAuB,CAAC;AAEzD,IAAIU,aAAa,GAAG7B,IAAI,CAACmB,OAAO,CAAC,oBAAoB,CAAC;AAEtD,IAAIW,SAAS,GAAG;EAAChB,OAAO,EAAE;AAAC,CAAC;AAE5Bb,MAAM,CAACC,OAAO,CAAC6B,WAAW,GAAG,UAASC,KAAK,EAAE;EAC3C,IAAIjB,OAAO,GAAGiB,KAAK,CAACjB,OAAO;EAC3B,QAAQiB,KAAK,CAACN,IAAI;IAClB,KAAKpB,YAAY;MACf,IAAI2B,SAAS,GAAGJ,aAAa,CAACd,OAAO,CAAC;MACtC,IAAImB,EAAE,GAAGD,SAAS,CAACC,EAAE;MACrB,IAAIC,MAAM,GAAGrC,MAAM,CAACoC,EAAE,EAAED,SAAS,CAACG,IAAI,CAAC;MACvC,OAAO;QAACF,EAAE,EAAEA,EAAE;QAAEpB,OAAO,EAAEkB,KAAK,CAAClB,OAAO;QAAEqB,MAAM,EAAEA;MAAM,CAAC;IACzD,KAAK3B,YAAY;MACf,IAAI6B,KAAK,GAAGT,aAAa,CAACb,OAAO,CAAC;MAClC,IAAImB,EAAE,GAAGG,KAAK,CAAC,OAAO,CAAC;MACvB,IAAIF,MAAM,GAAGrC,MAAM,CAACoC,EAAE,EAAEG,KAAK,CAACC,cAAc,CAAC;MAC7C,OAAO;QAACJ,EAAE,EAAEA,EAAE;QAAEpB,OAAO,EAAEkB,KAAK,CAAClB,OAAO;QAC9BE,IAAI,EAAEqB,KAAK,CAACrB,IAAI;QAAEmB,MAAM,EAAEA;MAAM,CAAC;IAC3C,KAAK1B,UAAU;MACb,OAAO;QAACK,OAAO,EAAEkB,KAAK,CAAClB,OAAO;QAAEyB,OAAO,EAAEP,KAAK,CAACjB;MAAO,CAAC;IACzD,KAAKR,eAAe;MAClB,OAAOuB,SAAS;IAClB;MACE,MAAM,IAAIL,KAAK,CAAC,qBAAqB,GAAGO,KAAK,CAACN,IAAI,CAAC;EACrD;AACF,CAAC;;AAED;AACAzB,MAAM,CAACC,OAAO,CAACsC,aAAa,GAAGzC,MAAM,CAAC0C,IAAI,CAAC,CAAC5C,SAAS,CAACU,eAAe,EAC1B,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;AAAE;AACZ,CAAC,EAAE,CAAC;AAAE;AACNV,SAAS,CAACa,SAAS,CAAC,CAAC;AAEhET,MAAM,CAACC,OAAO,CAAC4B,SAAS,GAAGA,SAAS","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}