{"ast":null,"code":"var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar utils = require('../utils');\nmodule.exports = {\n  privateExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var d = key.d.toBuffer();\n    var p = key.p.toBuffer();\n    var q = key.q.toBuffer();\n    var dmp1 = key.dmp1.toBuffer();\n    var dmq1 = key.dmq1.toBuffer();\n    var coeff = key.coeff.toBuffer();\n    var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.writeInt(0);\n    writer.writeBuffer(n, 2);\n    writer.writeInt(key.e);\n    writer.writeBuffer(d, 2);\n    writer.writeBuffer(p, 2);\n    writer.writeBuffer(q, 2);\n    writer.writeBuffer(dmp1, 2);\n    writer.writeBuffer(dmq1, 2);\n    writer.writeBuffer(coeff, 2);\n    writer.endSequence();\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return '-----BEGIN RSA PRIVATE KEY-----\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n-----END RSA PRIVATE KEY-----';\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n      if (_.isString(data)) {\n        var pem = data.replace('-----BEGIN RSA PRIVATE KEY-----', '').replace('-----END RSA PRIVATE KEY-----', '').replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = new Buffer(pem, 'base64');\n      } else {\n        throw Error('Unsupported key format');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    reader.readString(2, true); // just zero\n    key.setPrivate(reader.readString(2, true),\n    // modulus\n    reader.readString(2, true),\n    // publicExponent\n    reader.readString(2, true),\n    // privateExponent\n    reader.readString(2, true),\n    // prime1\n    reader.readString(2, true),\n    // prime2\n    reader.readString(2, true),\n    // exponent1 -- d mod (p1)\n    reader.readString(2, true),\n    // exponent2 -- d mod (q-1)\n    reader.readString(2, true) // coefficient -- (inverse of q) mod p\n    );\n  },\n  publicExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var length = n.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.startSequence();\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.endSequence();\n    if (options.type === 'der') {\n      return bodyWriter.buffer;\n    } else {\n      return '-----BEGIN RSA PUBLIC KEY-----\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n-----END RSA PUBLIC KEY-----';\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n      if (_.isString(data)) {\n        var pem = data.replace('-----BEGIN RSA PUBLIC KEY-----', '').replace('-----END RSA PUBLIC KEY-----', '').replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = new Buffer(pem, 'base64');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n    var body = new ber.Reader(buffer);\n    body.readSequence();\n    key.setPublic(body.readString(0x02, true),\n    // modulus\n    body.readString(0x02, true) // publicExponent\n    );\n  },\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    if (/^\\s*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----\\s*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n    if (/^\\s*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----\\s*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n    return false;\n  }\n};","map":{"version":3,"names":["ber","require","Ber","_","utils","module","exports","privateExport","key","options","n","toBuffer","d","p","q","dmp1","dmq1","coeff","length","writer","Writer","size","startSequence","writeInt","writeBuffer","e","endSequence","type","buffer","linebrk","toString","privateImport","data","Buffer","isBuffer","isString","pem","replace","Error","reader","Reader","readSequence","readString","setPrivate","publicExport","bodyWriter","publicImport","body","setPublic","autoImport","test"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/node-rsa/src/formats/pkcs1.js"],"sourcesContent":["var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar utils = require('../utils');\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var writer = new ber.Writer({size: length});\n\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.writeBuffer(n, 2);\n        writer.writeInt(key.e);\n        writer.writeBuffer(d, 2);\n        writer.writeBuffer(p, 2);\n        writer.writeBuffer(q, 2);\n        writer.writeBuffer(dmp1, 2);\n        writer.writeBuffer(dmq1, 2);\n        writer.writeBuffer(coeff, 2);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return '-----BEGIN RSA PRIVATE KEY-----\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n-----END RSA PRIVATE KEY-----';\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = data.replace('-----BEGIN RSA PRIVATE KEY-----', '')\n                    .replace('-----END RSA PRIVATE KEY-----', '')\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = new Buffer(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readString(2, true); // just zero\n        key.setPrivate(\n            reader.readString(2, true),  // modulus\n            reader.readString(2, true),  // publicExponent\n            reader.readString(2, true),  // privateExponent\n            reader.readString(2, true),  // prime1\n            reader.readString(2, true),  // prime2\n            reader.readString(2, true),  // exponent1 -- d mod (p1)\n            reader.readString(2, true),  // exponent2 -- d mod (q-1)\n            reader.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        if (options.type === 'der') {\n            return bodyWriter.buffer;\n        } else {\n            return '-----BEGIN RSA PUBLIC KEY-----\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n-----END RSA PUBLIC KEY-----';\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = data.replace('-----BEGIN RSA PUBLIC KEY-----', '')\n                    .replace('-----END RSA PUBLIC KEY-----', '')\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = new Buffer(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var body = new ber.Reader(buffer);\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        if (/^\\s*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----\\s*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^\\s*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----\\s*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}