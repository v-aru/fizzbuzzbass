{"ast":null,"code":"//\n//\n//\n\n'use strict';\n\n// A Mux is an object into which other readable streams may be piped;\n// it then writes 'packets' from the upstreams to the given\n// downstream.\nvar inherits = require('util').inherits;\nvar assert = require('assert');\nvar schedule = typeof setImmediate === 'function' ? setImmediate : process.nextTick;\nfunction Mux(downstream) {\n  this.newStreams = [];\n  this.oldStreams = [];\n  this.blocked = false;\n  this.scheduledRead = false;\n  this.out = downstream;\n  var self = this;\n  downstream.on('drain', function () {\n    self.blocked = false;\n    self._readIncoming();\n  });\n}\n\n// There are 2 states we can be in:\n\n// - waiting for outbound capacity, which will be signalled by a\n// - 'drain' event on the downstream; or,\n\n// - no packets to send, waiting for an inbound buffer to have\n//   packets, which will be signalled by a 'readable' event\n\n// If we write all packets available whenever there is outbound\n// capacity, we will either run out of outbound capacity (`#write`\n// returns false), or run out of packets (all calls to an\n// `inbound.read()` have returned null).\n\nMux.prototype._readIncoming = function () {\n  // We may be sent here speculatively, if an incoming stream has\n  // become readable\n  if (this.blocked) return;\n  var self = this;\n  var accepting = true;\n  var out = this.out;\n\n  // Try to read a chunk from each stream in turn, until all streams\n  // are empty, or we exhaust our ability to accept chunks.\n  function roundrobin(streams) {\n    var s;\n    // if there's just one incoming stream we don't have to\n    // go through all the dequeue/enqueueing\n    if (streams.length === 1) {\n      s = streams.shift();\n      while (accepting) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n        } else break;\n      }\n      if (!accepting) streams.push(s);\n    } else {\n      while (accepting && (s = streams.shift())) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n          streams.push(s);\n        }\n      }\n    }\n  }\n  roundrobin(this.newStreams);\n\n  // Either we exhausted the new queues, or we ran out of capacity. If\n  // we ran out of capacity, all the remaining new streams (i.e.,\n  // those with packets left) become old streams. This effectively\n  // prioritises streams that keep their buffers close to empty over\n  // those that are constantly near full.\n\n  if (accepting) {\n    // all new queues are exhausted, write as many as\n    // we can from the old streams\n    assert.equal(0, this.newStreams.length);\n    roundrobin(this.oldStreams);\n  } else {\n    // ran out of room\n    assert(this.newStreams.length > 0, \"Expect some new streams to remain\");\n    this.oldStreams = this.oldStreams.concat(this.newStreams);\n    this.newStreams = [];\n  }\n  // We may have exhausted all the old queues, or run out of room;\n  // either way, all we need to do is record whether we have capacity\n  // or not, so any speculative reads will know\n  this.blocked = !accepting;\n};\nMux.prototype._scheduleRead = function () {\n  var self = this;\n  if (!self.scheduledRead) {\n    schedule(function () {\n      self.scheduledRead = false;\n      self._readIncoming();\n    });\n    self.scheduledRead = true;\n  }\n};\nMux.prototype.pipeFrom = function (readable) {\n  var self = this;\n  function enqueue() {\n    self.newStreams.push(readable);\n    self._scheduleRead();\n  }\n  function cleanup() {\n    readable.removeListener('readable', enqueue);\n    readable.removeListener('error', cleanup);\n    readable.removeListener('end', cleanup);\n    readable.removeListener('unpipeFrom', cleanupIfMe);\n  }\n  function cleanupIfMe(dest) {\n    if (dest === self) cleanup();\n  }\n  readable.on('unpipeFrom', cleanupIfMe);\n  readable.on('end', cleanup);\n  readable.on('error', cleanup);\n  readable.on('readable', enqueue);\n};\nMux.prototype.unpipeFrom = function (readable) {\n  readable.emit('unpipeFrom', this);\n};\nmodule.exports.Mux = Mux;","map":{"version":3,"names":["inherits","require","assert","schedule","setImmediate","process","nextTick","Mux","downstream","newStreams","oldStreams","blocked","scheduledRead","out","self","on","_readIncoming","prototype","accepting","roundrobin","streams","s","length","shift","chunk","read","write","push","equal","concat","_scheduleRead","pipeFrom","readable","enqueue","cleanup","removeListener","cleanupIfMe","dest","unpipeFrom","emit","module","exports"],"sources":["/Users/anandarunima/Documents/Arunima/Coursework/sauce_labs-fizzbuzzbash/fizzbuzzbass/components/node_modules/amqplib/lib/mux.js"],"sourcesContent":["//\n//\n//\n\n'use strict';\n\n// A Mux is an object into which other readable streams may be piped;\n// it then writes 'packets' from the upstreams to the given\n// downstream.\n\nvar inherits = require('util').inherits;\nvar assert = require('assert');\n\nvar schedule = (typeof setImmediate === 'function') ?\n  setImmediate : process.nextTick;\n\nfunction Mux(downstream) {\n  this.newStreams = [];\n  this.oldStreams = [];\n  this.blocked = false;\n  this.scheduledRead = false;\n\n  this.out = downstream;\n  var self = this;\n  downstream.on('drain', function() {\n    self.blocked = false;\n    self._readIncoming();\n  });\n}\n\n// There are 2 states we can be in:\n\n// - waiting for outbound capacity, which will be signalled by a\n// - 'drain' event on the downstream; or,\n\n// - no packets to send, waiting for an inbound buffer to have\n//   packets, which will be signalled by a 'readable' event\n\n// If we write all packets available whenever there is outbound\n// capacity, we will either run out of outbound capacity (`#write`\n// returns false), or run out of packets (all calls to an\n// `inbound.read()` have returned null).\n\nMux.prototype._readIncoming = function() {\n\n  // We may be sent here speculatively, if an incoming stream has\n  // become readable\n  if (this.blocked) return;\n\n  var self = this;\n  var accepting = true;\n  var out = this.out;\n\n  // Try to read a chunk from each stream in turn, until all streams\n  // are empty, or we exhaust our ability to accept chunks.\n  function roundrobin(streams) {\n    var s;\n    // if there's just one incoming stream we don't have to\n    // go through all the dequeue/enqueueing\n    if (streams.length === 1) {\n      s = streams.shift();\n      while (accepting) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n        }\n        else break;\n      }\n      if (!accepting) streams.push(s);\n    }\n    else {\n      while (accepting && (s = streams.shift())) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n          streams.push(s);\n        }\n      }\n    }\n  }\n\n  roundrobin(this.newStreams);\n\n  // Either we exhausted the new queues, or we ran out of capacity. If\n  // we ran out of capacity, all the remaining new streams (i.e.,\n  // those with packets left) become old streams. This effectively\n  // prioritises streams that keep their buffers close to empty over\n  // those that are constantly near full.\n\n  if (accepting) { // all new queues are exhausted, write as many as\n                   // we can from the old streams\n    assert.equal(0, this.newStreams.length);\n    roundrobin(this.oldStreams);\n  }\n  else { // ran out of room\n    assert(this.newStreams.length > 0, \"Expect some new streams to remain\");\n    this.oldStreams = this.oldStreams.concat(this.newStreams);\n    this.newStreams = [];\n  }\n  // We may have exhausted all the old queues, or run out of room;\n  // either way, all we need to do is record whether we have capacity\n  // or not, so any speculative reads will know\n  this.blocked = !accepting;\n};\n\nMux.prototype._scheduleRead = function() {\n  var self = this;\n  \n  if (!self.scheduledRead) {\n    schedule(function() {\n      self.scheduledRead = false;\n      self._readIncoming();\n    });\n    self.scheduledRead = true;\n  }\n};\n\nMux.prototype.pipeFrom = function(readable) {\n  var self = this;\n\n  function enqueue() {\n    self.newStreams.push(readable);\n    self._scheduleRead();\n  }\n\n  function cleanup() {\n    readable.removeListener('readable', enqueue);\n    readable.removeListener('error', cleanup);\n    readable.removeListener('end', cleanup);\n    readable.removeListener('unpipeFrom', cleanupIfMe);\n  }\n  function cleanupIfMe(dest) {\n    if (dest === self) cleanup();\n  }\n\n  readable.on('unpipeFrom', cleanupIfMe);\n  readable.on('end', cleanup);\n  readable.on('error', cleanup);\n  readable.on('readable', enqueue);\n};\n\nMux.prototype.unpipeFrom = function(readable) {\n  readable.emit('unpipeFrom', this);\n};\n\nmodule.exports.Mux = Mux;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}